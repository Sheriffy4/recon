"""
Unit tests for AutoTTL calculation in bypass engine.
def apply_forced_override(original_func, *args, **kwargs):
    """
    ÐžÐ±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹.
    ÐšÐ Ð˜Ð¢Ð˜Ð§Ð•Ð¡ÐšÐžÐ• Ð˜Ð¡ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð• Ð´Ð»Ñ Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ‡Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ñ Ñ€ÐµÐ¶Ð¸Ð¼Ð¾Ð¼ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ.
    """
    # Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ forced Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹
    if len(args) > 1 and isinstance(args[1], dict):
        # Ð’Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚ - ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ
        strategy = args[1].copy()
        strategy['no_fallbacks'] = True
        strategy['forced'] = True
        args = (args[0], strategy) + args[2:]
        print(f"ðŸ”¥ FORCED OVERRIDE: Applied to {args[0] if args else 'unknown'}")
    
    return original_func(*args, **kwargs)



Tests the implementation of task 4: Implement AutoTTL Calculation in Bypass Engine
- Subtask 4.1: Network hop probing
- Subtask 4.2: calculate_autottl method
- Subtask 4.3: Integration into packet building
"""

import unittest
import time
from unittest.mock import Mock, patch, MagicMock
from core.bypass.engine.base_engine import WindowsBypassEngine, EngineConfig


class TestAutoTTLCalculation(unittest.TestCase):
    """Test AutoTTL calculation functionality."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.config = EngineConfig(debug=False)
        
        # Mock pydivert to avoid requiring Windows
        with patch('core.bypass.engine.base_engine.pydivert'):
            self.engine = WindowsBypassEngine(self.config)
    
    def test_probe_hops_private_network(self):
        """Test hop probing for private network IPs."""
        # Test 10.x.x.x (private network)
        hops = self.engine._probe_hops("10.0.0.1")
        self.assertIsInstance(hops, int)
        self.assertGreaterEqual(hops, 1)
        self.assertLessEqual(hops, 5)
        
        # Test 192.168.x.x (private network)
        hops = self.engine._probe_hops("192.168.1.1")
        self.assertIsInstance(hops, int)
        self.assertGreaterEqual(hops, 1)
        self.assertLessEqual(hops, 5)
    
    def test_probe_hops_public_network(self):
        """Test hop probing for public network IPs."""
        # Test Class A (international)
        hops = self.engine._probe_hops("8.8.8.8")
        self.assertIsInstance(hops, int)
        self.assertGreaterEqual(hops, 5)
        self.assertLessEqual(hops, 20)
        
        # Test Class B (national)
        hops = self.engine._probe_hops("172.66.0.227")  # x.com IP
        self.assertIsInstance(hops, int)
        self.assertGreaterEqual(hops, 5)
        self.assertLessEqual(hops, 15)
    
    def test_probe_hops_error_handling(self):
        """Test hop probing handles errors gracefully."""
        # Test with invalid IP (should return default)
        hops = self.engine._probe_hops("invalid.ip.address")
        self.assertIsInstance(hops, int)
        self.assertEqual(hops, 8)  # Default fallback
    
    def test_calculate_autottl_basic(self):
        """Test basic AutoTTL calculation."""
        dest_ip = "172.66.0.227"  # x.com IP
        autottl_offset = 2
        
        ttl = self.engine.calculate_autottl(dest_ip, autottl_offset)
        
        self.assertIsInstance(ttl, int)
        self.assertGreaterEqual(ttl, 1)
        self.assertLessEqual(ttl, 255)
    
    def test_calculate_autottl_clamping(self):
        """Test that AutoTTL clamps values to valid range [1, 255]."""
        dest_ip = "8.8.8.8"
        
        # Test with very large offset (should clamp to 255)
        ttl = self.engine.calculate_autottl(dest_ip, 250)
        self.assertLessEqual(ttl, 255)
        
        # Test with negative offset (should clamp to 1)
        # First, manually set a low hop count in cache
        self.engine._autottl_cache[dest_ip] = (2, time.time())
        ttl = self.engine.calculate_autottl(dest_ip, -5)
        self.assertGreaterEqual(ttl, 1)
    
    def test_calculate_autottl_caching(self):
        """Test that AutoTTL results are cached."""
        dest_ip = "172.66.0.227"
        autottl_offset = 2
        
        # First call - should probe and cache
        ttl1 = self.engine.calculate_autottl(dest_ip, autottl_offset)
        
        # Verify cache entry exists
        self.assertIn(dest_ip, self.engine._autottl_cache)
        cached_hops, cached_time = self.engine._autottl_cache[dest_ip]
        
        # Second call - should use cache
        ttl2 = self.engine.calculate_autottl(dest_ip, autottl_offset)
        
        # Results should be identical (using cached value)
        self.assertEqual(ttl1, ttl2)
    
    def test_calculate_autottl_cache_expiry(self):
        """Test that AutoTTL cache expires after TTL."""
        dest_ip = "172.66.0.227"
        autottl_offset = 2
        
        # Manually set an expired cache entry
        old_time = time.time() - 400  # 400 seconds ago (> 300s cache TTL)
        self.engine._autottl_cache[dest_ip] = (10, old_time)
        
        # Call should re-probe (cache expired)
        ttl = self.engine.calculate_autottl(dest_ip, autottl_offset)
        
        # Verify cache was updated with new timestamp
        _, new_time = self.engine._autottl_cache[dest_ip]
        self.assertGreater(new_time, old_time)
    
    def test_calculate_autottl_error_handling(self):
        """Test that AutoTTL handles errors gracefully."""
        # Mock _probe_hops to raise an exception
        with patch.object(self.engine, '_probe_hops', side_effect=Exception("Network error")):
            ttl = self.engine.calculate_autottl("8.8.8.8", 2)
            
            # Should return default TTL=64 on error
            self.assertEqual(ttl, 64)
    
    def test_calculate_autottl_different_offsets(self):
        """Test AutoTTL with different offset values."""
        dest_ip = "172.66.0.227"
        
        # Manually set hop count in cache for consistent testing
        self.engine._autottl_cache[dest_ip] = (10, time.time())
        
        # Test offset=1
        ttl1 = self.engine.calculate_autottl(dest_ip, 1)
        self.assertEqual(ttl1, 11)  # 10 hops + 1 offset
        
        # Test offset=2
        ttl2 = self.engine.calculate_autottl(dest_ip, 2)
        self.assertEqual(ttl2, 12)  # 10 hops + 2 offset
        
        # Test offset=5
        ttl5 = self.engine.calculate_autottl(dest_ip, 5)
        self.assertEqual(ttl5, 15)  # 10 hops + 5 offset


class TestAutoTTLIntegration(unittest.TestCase):
    """Test AutoTTL integration into packet building."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.config = EngineConfig(debug=False)
        
        # Mock pydivert
        with patch('core.bypass.engine.base_engine.pydivert'):
            self.engine = WindowsBypassEngine(self.config)
    
    def test_apply_bypass_with_autottl(self):
        """Test that apply_bypass uses calculated TTL when autottl is set."""
        # Create mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "172.66.0.227"
        mock_packet.dst_port = 443
        mock_packet.src_addr = "192.168.1.100"
        mock_packet.src_port = 54321
        mock_packet.payload = b'\x16\x03\x01' + b'\x00' * 100  # Fake TLS ClientHello
        
        # Create mock WinDivert
        mock_w = Mock()
        
        # Strategy with autottl
        strategy_task = {
            "type": "fakeddisorder",
            "params": {
                "autottl": 2,
                "split_pos": 46,
                "overlap_size": 1,
                "fooling": ["badseq"]
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock calculate_autottl to return a known value
        with patch.object(self.engine, 'calculate_autottl', return_value=10) as mock_calc:
            # Mock the techniques and packet sender to avoid actual packet building
            with patch.object(self.engine.techniques, 'apply_fakeddisorder', return_value=[]):
                with patch.object(self.engine._packet_sender, 'send_tcp_segments'):
                    # Call apply_bypass
                    self.engine.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
                    
                    # Verify calculate_autottl was called with correct parameters
                    mock_calc.assert_called_once_with("172.66.0.227", 2)
    
    def test_apply_bypass_with_fixed_ttl(self):
        """Test that apply_bypass uses fixed TTL when specified."""
        # Create mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "172.66.0.227"
        mock_packet.dst_port = 443
        mock_packet.src_addr = "192.168.1.100"
        mock_packet.src_port = 54321
        mock_packet.payload = b'\x16\x03\x01' + b'\x00' * 100
        
        mock_w = Mock()
        
        # Strategy with fixed TTL (no autottl)
        strategy_task = {
            "type": "fakeddisorder",
            "params": {
                "ttl": 3,
                "split_pos": 46,
                "overlap_size": 1,
                "fooling": ["badseq"]
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock calculate_autottl - should NOT be called
        with patch.object(self.engine, 'calculate_autottl') as mock_calc:
            with patch.object(self.engine.techniques, 'apply_fakeddisorder', return_value=[]):
                with patch.object(self.engine._packet_sender, 'send_tcp_segments'):
                    self.engine.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
                    
                    # Verify calculate_autottl was NOT called
                    mock_calc.assert_not_called()
    
    def test_apply_bypass_autottl_fallback(self):
        """Test that apply_bypass falls back to default TTL on autottl error."""
        mock_packet = Mock()
        mock_packet.dst_addr = "172.66.0.227"
        mock_packet.dst_port = 443
        mock_packet.src_addr = "192.168.1.100"
        mock_packet.src_port = 54321
        mock_packet.payload = b'\x16\x03\x01' + b'\x00' * 100
        
        mock_w = Mock()
        
        strategy_task = {
            "type": "fakeddisorder",
            "params": {
                "autottl": 2,
                "split_pos": 46,
                "fooling": ["badseq"]
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock calculate_autottl to raise an exception
        with patch.object(self.engine, 'calculate_autottl', side_effect=Exception("Network error")):
            with patch.object(self.engine.techniques, 'apply_fakeddisorder', return_value=[]):
                with patch.object(self.engine._packet_sender, 'send_tcp_segments'):
                    # Should not raise exception - should handle gracefully
                    try:
                        self.engine.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
                    except Exception as e:
                        self.fail(f"apply_bypass raised exception: {e}")


if __name__ == '__main__':
    unittest.main()
