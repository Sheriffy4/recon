в корне проекта создал директорию recon в которой создал файл recon.py с кодом который ты предложил.

далее  что я предлагаю : всё разрабатывается в рамках того же проекта. то есть я создал просто поддиректорию в корне. надо создать его(модуль) максимально независимо от остального проекта. в идеале чтобы если взять папку с проектом "recon" перенести в отдельное место и там запустить без остальных текущих модулей, он заработал и выполнял свой функционал, возможно не полный так как он не должен заниматься именно генерацией стратегий. пока его задача выяснить как именно заблокирован домен и попытаться локально обойти эти ограничения.
пока мысль такая что этот модуль будет выявлять уязвимости в DPI и на основе этих знаний будет составлять стратегию по стандарту zapret, чтобы ее можно было "подкинуть"в эту программу и она работала.
тот код что я писал выше для примера тебе необходимо скомпоновать и с учетом предложенного тобой модуля recon.py написать мне код всех модулей вместе с учетом их расположений в директориях 
Отличная идея! Создание самодостаточного модуля recon — это идеальный подход. Он позволит вести разработку независимо, а в будущем легко интегрировать его результаты в основной пайплайн.
Я полностью поддерживаю вашу концепцию: recon должен быть автономным "разведчиком", который на выходе дает готовые к использованию стратегии Zapret.
Давайте спроектируем и напишем код для этого модуля.
Архитектура модуля recon
Generated code
DPI_Blockcheck/
├── recon/
│   ├── __init__.py
│   ├── recon.py             # Главный скрипт-оркестратор
│   ├── traffic_analyzer.py  # Низкоуровневая работа с пакетами (Scapy)
│   ├── technique_tester.py  # Логика тестирования отдельных техник (TTL, Split, etc.)
│   ├── strategy_builder.py  # Сборка финальной стратегии из успешных техник
│   └── config.py            # Конфигурация, специфичная для разведки
│
├── core/
│   └── ... (остальные модули проекта)
├── utils/
│   └── ...
└── iterative_master.py
Use code with caution.
Принцип работы:
recon.py — точка входа. Принимает на вход домен или IP.
Он вызывает TechniqueTester.
TechniqueTester использует TrafficAnalyzer для итеративного тестирования различных техник обхода (изменение TTL, разные виды сегментации, разные fooling-методы).
Каждая успешная техника (которая позволила установить соединение) запоминается.
После завершения тестов, StrategyBuilder собирает все успешные техники в одну или несколько валидных стратегий в формате zapret.
recon.py выводит готовую(ые) стратегию(и) в консоль.
Код Модулей
Вот полный код для каждого файла внутри директории recon/. Он написан так, чтобы быть максимально автономным.
1. recon/config.py
Здесь мы храним все настраиваемые параметры для модуля разведки.
Generated python
# recon/config.py

# --- Цели для тестирования ---
DEFAULT_TARGET_DOMAIN = "rutracker.org"
DEFAULT_TARGET_PORT = 443

# --- Параметры анализатора трафика ---
SOCKET_TIMEOUT = 5  # Секунд
PACKET_RECV_BUFFER = 4096  # Байт

# --- Конфигурация техник для тестирования ---
# Определяет, какие техники и с какими параметрами будет проверять "Разведчик"

TECHNIQUES_TO_TEST = {
    # Проверка базовой доступности
    "baseline": [
        {'type': 'baseline_tcp_handshake'}
    ],
    # Тестирование TTL
    "ttl": [
        {'type': 'ttl_variation', 'value': ttl} for ttl in [1, 2, 3, 4, 5, 7, 10, 15]
    ],
    # Тестирование методов "обмана" (fooling)
    "fooling": [
        {'type': 'fooling_variation', 'value': 'badsum'},
        {'type': 'fooling_variation', 'value': 'md5sig'},
        {'type': 'fooling_variation', 'value': 'badseq'},
        # 'datanoack' требует более сложной настройки и может не работать везде
    ],
    # Тестирование сегментации TCP
    "split": [
        {'type': 'split_variation', 'params': {'split-pos': '1'}},
        {'type': 'split_variation', 'params': {'split-pos': '2'}},
        {'type': 'split_variation', 'params': {'split-pos': '3'}},
        {'type': 'split_variation', 'params': {'split-pos': 'host'}},
        {'type': 'split_variation', 'params': {'split-pos': 'midsld'}},
    ],
    # Тестирование сегментации с перекрытием (seqovl)
    "seqovl": [
        {'type': 'seqovl_variation', 'params': {'split-pos': '3', 'split-seqovl': '10'}},
        {'type': 'seqovl_variation', 'params': {'split-pos': 'host', 'split-seqovl': '50'}},
    ]
}

# --- Параметры для сборки стратегии ---
# Приоритет техник при сборке финальной стратегии.
# Более надежные и "дешевые" техники должны идти первыми.
TECHNIQUE_PRIORITY = [
    'split',
    'seqovl',
    'fooling',
    'ttl'
]
Use code with caution.
Python
2. recon/traffic_analyzer.py
Низкоуровневый модуль для работы с сетью с помощью Scapy.
Generated python
# recon/traffic_analyzer.py

import logging
import random
from typing import Optional, Dict, Any

# Scapy импортируется внутри методов, чтобы избежать ошибки, если он не установлен
# и модуль импортируется где-то еще.
try:
    from scapy.all import IP, TCP, sr1, RandShort, Raw
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

from . import config

class TrafficAnalyzer:
    """Низкоуровневый анализатор трафика, использующий Scapy."""

    def __init__(self, target_ip: str, target_port: int, logger: logging.Logger):
        if not SCAPY_AVAILABLE:
            raise ImportError("Scapy is not installed. Please run 'pip install scapy'.")
        
        self.target_ip = target_ip
        self.target_port = target_port
        self.logger = logger

    def send_and_receive_tcp(self, custom_tcp_layer: Any, payload: Optional[bytes] = None) -> Optional[Any]:
        """
        Отправляет один TCP пакет и возвращает ответ.

        Args:
            custom_tcp_layer: Сконфигурированный TCP слой из Scapy.
            payload: Опциональная полезная нагрузка.

        Returns:
            Ответный пакет Scapy или None в случае таймаута.
        """
        ip_layer = IP(dst=self.target_ip)
        
        if payload:
            packet = ip_layer / custom_tcp_layer / Raw(load=payload)
        else:
            packet = ip_layer / custom_tcp_layer

        self.logger.debug(f"Sending packet: {packet.summary()}")
        
        # sr1 отправляет пакет и ждет одного ответа
        response = sr1(packet, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        if response:
            self.logger.debug(f"Received response: {response.summary()}")
        else:
            self.logger.debug("No response received (timeout).")
            
        return response

    def analyze_response(self, response: Optional[Any]) -> str:
        """
        Анализирует ответный пакет и возвращает его статус.
        """
        if response is None:
            return "TIMEOUT"
        
        if not response.haslayer(TCP):
            return "NON_TCP_RESPONSE"
            
        tcp_layer = response.getlayer(TCP)
        
        # Флаги: S=SYN, A=ACK, R=RST, F=FIN, P=PSH, U=URG
        # Идеальный ответ на SYN - это SYN-ACK
        if tcp_layer.flags.S and tcp_layer.flags.A:
            return "SUCCESS" # SYN-ACK получен, соединение можно устанавливать
        
        # Если пришел RST (сброс соединения) - это явный признак блокировки
        if tcp_layer.flags.R:
            return "RST_RECEIVED"
            
        return "UNEXPECTED_RESPONSE"
Use code with caution.
Python
3. recon/technique_tester.py
Модуль, который содержит логику тестирования каждой отдельной техники.
Generated python
# recon/technique_tester.py

import logging
from typing import Dict, Any, Optional

from .traffic_analyzer import TrafficAnalyzer
from scapy.all import TCP, RandShort

class TechniqueTester:
    """Тестирует отдельные техники обхода DPI."""

    def __init__(self, analyzer: TrafficAnalyzer, logger: logging.Logger):
        self.analyzer = analyzer
        self.logger = logger

    def test_technique(self, technique: Dict[str, Any]) -> str:
        """
        Выполняет тест для одной техники и возвращает результат.
        """
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        # Базовый TCP SYN пакет
        tcp_layer = TCP(dport=self.analyzer.target_port, sport=RandShort(), flags='S')
        payload = b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n" # Примерная нагрузка

        # Модифицируем пакет в зависимости от техники
        if tech_type == 'baseline_tcp_handshake':
            pass # Используем базовый пакет
        elif tech_type == 'ttl_variation':
            # Эта техника не меняет пакет, а будет применена в TrafficAnalyzer
            # Здесь мы просто передаем информацию дальше
            pass # TTL будет установлен в TrafficAnalyzer на уровне IP
        elif tech_type == 'fooling_variation':
            # Scapy не поддерживает все fooling-методы Zapret напрямую.
            # 'badsum' и 'badseq' можно симулировать.
            if technique['value'] == 'badseq':
                tcp_layer.seq = 12345 # Невалидный seq
            # badsum Scapy исправляет автоматически, это сложнее. Пока пропустим.
            else:
                self.logger.warning(f"Fooling method '{technique['value']}' not yet supported in recon.")
                return "NOT_SUPPORTED"
        elif tech_type == 'split_variation':
            # Для симуляции сплита мы просто отправляем очень маленький пакет
            payload = payload[:int(technique['params']['split-pos'])]
        elif tech_type == 'seqovl_variation':
            # Это сложная техника, для разведки мы можем симулировать ее
            # отправкой двух пакетов, что выходит за рамки простого send_and_receive_tcp.
            # Пока возвращаем "не поддерживается".
            return "NOT_SUPPORTED"
        else:
            self.logger.error(f"Unknown technique type: {tech_type}")
            return "UNKNOWN_TECHNIQUE"

        # Отправляем модифицированный пакет
        response = self.analyzer.send_and_receive_tcp(tcp_layer, payload)
        
        # Анализируем результат
        return self.analyzer.analyze_response(response)
Use code with caution.
Python
4. recon/strategy_builder.py
Собирает успешные техники в готовую строку для Zapret.
Generated python
# recon/strategy_builder.py

import logging
from typing import List, Dict, Any
from . import config

class ReconStrategyBuilder:
    """Собирает финальную стратегию из успешных техник."""

    def __init__(self, logger: logging.Logger):
        self.logger = logger

    def build(self, successful_techniques: List[Dict[str, Any]]) -> str:
        """
        Собирает итоговую строку стратегии.
        """
        if not successful_techniques:
            return "--dpi-desync=fake # Fallback: no successful techniques found"

        # Сортируем техники по приоритету
        sorted_techniques = sorted(
            successful_techniques,
            key=lambda t: config.TECHNIQUE_PRIORITY.index(t['type'].split('_')[0])
        )
        
        self.logger.info(f"Building strategy from successful techniques: {sorted_techniques}")

        # --- Логика сборки ---
        # Начнем с простого: берем лучшую по приоритету технику.
        # В будущем можно будет комбинировать.
        
        best_technique = sorted_techniques[0]
        
        # Собираем base_type
        # Для простоты, пока считаем, что сплит - это multisplit
        base_type = "multisplit" if "split" in best_technique['type'] else "fake"
        
        params = {}
        if 'ttl' in best_technique['type']:
            params['ttl'] = best_technique['value']
        if 'fooling' in best_technique['type']:
            params['fooling'] = best_technique['value']
        if 'split' in best_technique['type']:
            params.update(best_technique['params'])
            
        # Формируем строку
        strategy_parts = [f"--dpi-desync={base_type}"]
        for key, value in params.items():
            strategy_parts.append(f"--dpi-desync-{key}={value}")
            
        return " ".join(strategy_parts)
Use code with caution.
Python
5. recon/recon.py
Главный файл, который запускает весь процесс.
Generated python
# recon/recon.py

import argparse
import logging
import socket
from typing import List, Dict, Any

# Импортируем компоненты из нашего же модуля
from . import config
from .traffic_analyzer import TrafficAnalyzer
from .technique_tester import TechniqueTester
from .strategy_builder import ReconStrategyBuilder

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("ReconApp")


def run_reconnaissance(target_domain: str, target_port: int):
    """
    Основная функция-оркестратор для запуска разведки.
    """
    logger.info(f"Starting reconnaissance for {target_domain}:{target_port}")

    # 1. Резолвим домен в IP
    try:
        target_ip = socket.gethostbyname(target_domain)
        logger.info(f"Resolved {target_domain} to {target_ip}")
    except socket.gaierror:
        logger.error(f"Could not resolve domain: {target_domain}")
        return

    # 2. Инициализация компонентов
    try:
        analyzer = TrafficAnalyzer(target_ip, target_port, logger)
        tester = TechniqueTester(analyzer, logger)
        builder = ReconStrategyBuilder(logger)
    except ImportError as e:
        logger.critical(f"Failed to initialize components: {e}")
        logger.critical("Please make sure 'scapy' is installed (`pip install scapy`).")
        return

    # 3. Тестирование техник
    successful_techniques: List[Dict[str, Any]] = []
    
    for category, techniques in config.TECHNIQUES_TO_TEST.items():
        logger.info(f"--- Testing category: {category.upper()} ---")
        for tech in techniques:
            result = tester.test_technique(tech)
            if result == "SUCCESS":
                logger.info(f"[+] SUCCESS: Technique {tech} worked!")
                successful_techniques.append(tech)
                # Если нашли рабочую технику, можно прервать категорию и перейти к следующей
                break 
            else:
                logger.info(f"[-] FAIL: Technique {tech} result: {result}")
        
        if successful_techniques and category == 'baseline':
             logger.info("Baseline connection successful. Target does not seem to be blocked.")
             return

    # 4. Сборка и вывод стратегии
    if successful_techniques:
        final_strategy = builder.build(successful_techniques)
        logger.info("="*50)
        logger.info("Reconnaissance complete. Found a working strategy:")
        print("\n--- Recommended Zapret Strategy ---")
        print(final_strategy)
        print("---------------------------------\n")
    else:
        logger.warning("="*50)
        logger.warning("Reconnaissance complete. No simple working techniques found.")
        logger.warning("The block might be more complex or the host is down.")


def main():
    parser = argparse.ArgumentParser(description="DPI Reconnaissance Tool")
    parser.add_argument(
        "domain",
        nargs='?',
        default=config.DEFAULT_TARGET_DOMAIN,
        help=f"The target domain to test (default: {config.DEFAULT_TARGET_DOMAIN})"
    )
    parser.add_argument(
        "-p", "--port",
        type=int,
        default=config.DEFAULT_TARGET_PORT,
        help=f"The target port (default: {config.DEFAULT_TARGET_PORT})"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.info("Debug mode enabled.")

    run_reconnaissance(args.domain, args.port)


if __name__ == "__main__":
    # Этот блок позволяет запускать скрипт напрямую
    main()
Use code with caution.
Python
6. recon/__init__.py
Пустой файл, который помечает директорию recon как Python-пакет.
Generated python
# recon/__init__.py
# This file can be empty.
Use code with caution.
Python
Как это использовать?
Создайте директорию recon в корне вашего проекта.
Поместите все 5 файлов (__init__.py, recon.py, config.py, traffic_analyzer.py, technique_tester.py, strategy_builder.py) в эту директорию.
Установите scapy: pip install scapy
Запустите разведку из корня проекта:
Generated bash
# Запуск с правами суперпользователя
sudo python -m recon.recon rutracker.org
Use code with caution.
Bash
Или с дебаг-логами:
Generated bash
sudo python -m recon.recon -v rutracker.org
Use code with caution.
Bash
Что дальше?
Это отличная основа. В будущем этот модуль можно развивать:
Добавить больше техник в config.py и реализовать их логику в technique_tester.py.
Усложнить ReconStrategyBuilder, чтобы он мог комбинировать несколько успешных техник в одну сложную стратегию.
Интегрировать ML-модель, которая будет предсказывать, какие техники стоит тестировать в первую очередь для конкретного IP-адреса (например, по его принадлежности к автономной системе).
Сохранять результаты в базу данных для последующего анализа и переобучения основной ML-модели проекта.
122.9s
Вы столкнулись с очень распространенной ошибкой в Python, связанной с тем, как он обрабатывает импорты и пакеты.

Анализ Ошибки

ImportError: attempted relative import with no known parent package

Что это значит: Вы пытаетесь запустить файл recon.py напрямую. Когда вы это делаете, Python не считает директорию recon/ пакетом. Он видит recon.py как обычный, одиночный скрипт.

В чем проблема: В коде recon.py есть строка from . import config. Точка . в начале означает "импортировать из текущего пакета". Но поскольку Python не знает, что recon/ — это пакет, он выдает ошибку, говоря "я не знаю, что такое 'текущий пакет'".

Почему так происходит?

Когда вы выполняете команду python recon/recon.py, вы говорите Python: "Вот конкретный файл, запусти его". Python не смотрит на структуру директорий выше.

Когда вы выполняете python -m recon.recon, вы говорите Python: "Найди пакет recon, а внутри него модуль recon, и запусти его как главный". В этом случае Python сначала находит пакет recon и понимает его структуру, поэтому относительные импорты (from . import ...) работают корректно.

Решение

Есть два способа исправить это, чтобы код работал так, как вы задумали.

Способ 1: Правильный запуск (Рекомендуемый)

Это самый правильный и "питонический" способ. Вам нужно запускать ваш модуль из корневой директории проекта, а не из поддиректории recon.

Перейдите в командной строке в корень вашего проекта:

Generated bash
cd C:\Users\admin\Downloads\zapretttt\DPI_Blockcheck\


Запустите модуль recon с помощью флага -m (module):

Generated bash
# Для Windows (без sudo)
python -m recon.recon rutracker.org
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Или с подробным логом:

Generated bash
python -m recon.recon -v rutracker.org
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Почему это работает: Флаг -m заставляет Python добавить текущую директорию (корень проекта) в sys.path. Он находит пакет recon, и все относительные импорты внутри него (from . import config) начинают работать правильно.

Способ 2: Модификация кода для прямого запуска (Менее предпочтительный, но полезен для отладки)

Если вы хотите иметь возможность запускать recon.py напрямую из любой директории, вам нужно "обмануть" Python, заставив его думать, что родительская директория является частью пути поиска модулей.

Файл: recon/recon.py

Решение: Добавить в самое начало файла специальный блок кода, который модифицирует sys.path.

Предлагаемый код:

Generated python
# recon/recon.py

import argparse
import logging
import socket
import sys
import os
from typing import List, Dict, Any

# --- НАЧАЛО ИЗМЕНЕНИЯ: Хак для прямого запуска ---
# Этот блок кода позволяет запускать скрипт напрямую (python recon.py)
# Он добавляет родительскую директорию в путь поиска модулей,
# чтобы относительные импорты работали.
if __name__ == "__main__" and __package__ is None:
    # Получаем путь к директории, в которой находится recon.py
    recon_dir = os.path.dirname(os.path.abspath(__file__))
    # Получаем путь к родительской директории (корень проекта)
    project_root = os.path.dirname(recon_dir)
    # Добавляем корень проекта в sys.path
    sys.path.insert(0, project_root)
    # Теперь можно использовать относительные импорты
    # Перезагружаем модуль recon как пакет
    import recon
    __package__ = "recon"
# --- КОНЕЦ ИЗМЕНЕНИЯ ---


# Импортируем компоненты из нашего же модуля
from . import config
from .traffic_analyzer import TrafficAnalyzer
from .technique_tester import TechniqueTester
from .strategy_builder import ReconStrategyBuilder

# ... (остальной код файла без изменений) ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Как это работает:

if __name__ == "__main__" and __package__ is None:: Эта проверка срабатывает только тогда, когда вы запускаете файл напрямую.

os.path.dirname(os.path.abspath(__file__)): Получает абсолютный путь к директории recon.

os.path.dirname(recon_dir): Получает путь к родительской директории, то есть к корню проекта DPI_Blockcheck.

sys.path.insert(0, project_root): Добавляет корень проекта в начало списка путей, где Python ищет модули.

Теперь, когда Python встречает from . import config, он смотрит в sys.path, находит DPI_Blockcheck, видит внутри пакет recon и успешно импортирует config из него.

Моя Рекомендация

Используйте Способ 1. Это стандартная практика для работы с пакетами в Python. Она не требует "хаков" в коде и делает структуру вашего проекта более понятной и предсказуемой.

Способ 2 полезен для быстрой отладки, но в долгосрочной перспективе лучше привыкнуть к запуску модулей через флаг -m.

Давайте продолжим, используя правильный метод запуска. Перейдите в корневую директорию и выполните команду:
python -m recon.recon rutracker.org

Отличное наблюдение! Вы столкнулись с фундаментальным различием между тем, как работает простой TCP-хендшейк и как работает полноценный HTTPS-запрос из браузера. Ваш "Разведчик" пока что слишком наивен.

Давайте разберемся, почему так происходит и как сделать наш инструмент умнее.

Анализ Ситуации: Почему recon.py видит SUCCESS, а браузер — нет?

Что делает recon.py сейчас:

Он отправляет один-единственный TCP-пакет с флагом S (SYN) на rutracker.org:443.

Сервер rutracker.org (или, скорее, Cloudflare перед ним) отвечает пакетом с флагами SA (SYN-ACK).

Ваш TrafficAnalyzer видит этот ответ и рапортует: "SUCCESS!", потому что с точки зрения TCP, рукопожатие можно установить.

Что делает браузер (и почему его блокируют):

Шаг 1: TCP Handshake. Браузер делает то же самое, что и ваш скрипт — устанавливает TCP-соединение. Этот шаг, скорее всего, проходит успешно.

Шаг 2: TLS Handshake. Сразу после установки TCP-соединения браузер начинает TLS-рукопожатие, чтобы установить зашифрованный канал (HTTPS). Он отправляет пакет ClientHello.

Шаг 3: Блокировка DPI. Именно в пакете ClientHello содержится самая "опасная" информация — SNI (Server Name Indication). В этом поле открытым текстом передается имя домена, к которому вы подключаетесь (rutracker.org).

DPI провайдера видит rutracker.org в SNI, понимает, что это заблокированный ресурс, и немедленно сбрасывает (RST) ваше TCP-соединение.

Результат: Браузер получает сброс соединения и показывает ошибку "Соединение сброшено".

Вывод: Ваш "Разведчик" сейчас проверяет только самый первый, базовый уровень сетевого взаимодействия (L4 - TCP), в то время как блокировка происходит на более высоком уровне (L7 - анализ TLS).

Как это исправить? Усложняем "Разведчика"

Нам нужно научить TrafficAnalyzer симулировать не просто TCP-хендшейк, а начало TLS-сессии, чтобы спровоцировать реакцию DPI.

План действий:

Создать "опасный" ClientHello: Нам нужен байтовый пакет, имитирующий ClientHello от браузера с указанием целевого домена в SNI.

Модифицировать TrafficAnalyzer: Научить его отправлять не просто SYN, а полноценное трехэтапное рукопожатие (SYN -> SYN-ACK -> ACK) и сразу после него — наш ClientHello.

Улучшить TechniqueTester: Адаптировать его для работы с новым, более сложным процессом тестирования.

Детальные Рекомендации по Коду
1. Создание ClientHello

К счастью, нам не нужно собирать его вручную. Мы можем перехватить реальный ClientHello с помощью Wireshark или просто использовать готовый. Для простоты, мы можем определить его как байтовую строку в recon/config.py.

Файл: recon/config.py

Generated python
# recon/config.py

# ... (существующие настройки) ...

# --- Параметры для симуляции TLS ---
# Это упрощенный ClientHello для example.com. Мы будем динамически подменять домен.
# В реальном проекте лучше взять дамп реального ClientHello от Chrome/Firefox.
TLS_CLIENT_HELLO_TEMPLATE = (
    b'\x16\x03\x01\x02\x00\x01\x00\x01\xfc\x03\x03' +
    b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f' +
    b'\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f' +
    b' \x00\x00\x1a\x13\x01\x13\x02\x13\x03\xc0+\xc0/\xc0,\xc00\xcc\xa9' +
    b'\xcc\xa8\xc0\x13\xc0\x14\x00\x9c\x00\x9d\x00/\x005\x01\x00\x01\x93' +
    # Далее идет блок расширений, включая SNI, который мы будем патчить
    b'\x00\x00\x00\x0e\x00\x0c\x00\x00\x09example.com' # Заглушка для SNI
)

def build_client_hello(domain: str) -> bytes:
    """Собирает ClientHello с указанным доменом в SNI."""
    # Это очень упрощенная реализация. Она заменяет домен-заглушку на реальный.
    # ВАЖНО: Длина домена и общая длина пакета должны быть пересчитаны.
    # Для простоты разведки мы пока можем проигнорировать точный пересчет длин,
    # так как DPI часто реагирует просто на наличие домена в строке.
    
    domain_bytes = domain.encode('utf-8')
    # Просто заменяем заглушку на реальный домен
    # В реальной системе нужно было бы пересобирать все расширение SNI
    return TLS_CLIENT_HELLO_TEMPLATE.replace(b'example.com', domain_bytes)

2. Модификация recon/traffic_analyzer.py

Теперь TrafficAnalyzer должен уметь устанавливать полное TCP-соединение и отправлять данные.

Generated python
# recon/traffic_analyzer.py

import logging
import random
from typing import Optional, Dict, Any

try:
    from scapy.all import IP, TCP, sr1, send, sniff, Raw, wrpcap
    from scapy.layers.tls.handshake import TLSClientHello
    from scapy.layers.tls.extensions import TLSExtension, TLSExtServerName, ServerName
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False

from . import config

class TrafficAnalyzer:
    """Низкоуровневый анализатор трафика, использующий Scapy."""

    def __init__(self, target_ip: str, target_port: int, logger: logging.Logger):
        if not SCAPY_AVAILABLE:
            raise ImportError("Scapy is not installed. Please run 'pip install scapy'.")
        
        self.target_ip = target_ip
        self.target_port = target_port
        self.logger = logger
        self.sport = RandShort() # Используем один и тот же порт источника для сессии

    def test_connection_with_payload(self, payload: bytes, custom_ip_layer: Optional[IP] = None) -> str:
        """
        Выполняет полное TCP-рукопожатие, отправляет payload и анализирует ответ.
        """
        # --- Шаг 1: SYN ---
        syn = IP(dst=self.target_ip) / TCP(sport=self.sport, dport=self.target_port, flags='S', seq=random.randint(0, 2**32-1))
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)

        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack[TCP].flags.S and syn_ack[TCP].flags.A):
            self.logger.warning("Step 1 (SYN->SYN-ACK) failed. No valid SYN-ACK received.")
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: ACK + PSH (отправка данных) ---
        # Формируем наш пакет с данными
        ip_layer = custom_ip_layer if custom_ip_layer else IP(dst=self.target_ip)
        
        ack_packet = ip_layer / TCP(
            sport=self.sport,
            dport=self.target_port,
            flags='PA', # PSH+ACK
            seq=syn_ack.ack,
            ack=syn_ack.seq + 1
        ) / Raw(load=payload)

        self.logger.debug(f"Sending ACK+PSH with payload: {ack_packet.summary()}")
        
        # Отправляем данные и ждем ответа (например, ServerHello или RST)
        response = sr1(ack_packet, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        return self.analyze_response(response)

    def analyze_response(self, response: Optional[Any]) -> str:
        """Анализирует ответный пакет и возвращает его статус."""
        if response is None:
            return "TIMEOUT"
        
        if not response.haslayer(TCP):
            return "NON_TCP_RESPONSE"
            
        tcp_layer = response.getlayer(TCP)
        
        # Если пришел RST (сброс соединения) - это явный признак блокировки
        if tcp_layer.flags.R:
            return "RST_RECEIVED"
        
        # Если пришел FIN (закрытие) - тоже признак блокировки
        if tcp_layer.flags.F:
            return "FIN_RECEIVED"

        # Если пришел ACK на наши данные - это хороший знак
        if tcp_layer.flags.A:
            # В идеале, здесь должен быть TLS ServerHello
            if response.haslayer(Raw):
                self.logger.info("Received ACK with data (likely ServerHello). SUCCESS!")
                return "SUCCESS"
            else:
                self.logger.info("Received pure ACK. Connection is likely alive.")
                return "SUCCESS"
            
        return "UNEXPECTED_RESPONSE"
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
3. Улучшение recon/technique_tester.py

Теперь тестер будет использовать новый метод test_connection_with_payload.

Generated python
# recon/technique_tester.py

import logging
from typing import Dict, Any, Optional

from .traffic_analyzer import TrafficAnalyzer
from . import config
from scapy.all import IP # Добавляем импорт

class TechniqueTester:
    """Тестирует отдельные техники обхода DPI."""

    def __init__(self, analyzer: TrafficAnalyzer, logger: logging.Logger, target_domain: str):
        self.analyzer = analyzer
        self.logger = logger
        self.target_domain = target_domain

    def test_technique(self, technique: Dict[str, Any]) -> str:
        """
        Выполняет тест для одной техники и возвращает результат.
        """
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        # Создаем "опасный" ClientHello
        payload = config.build_client_hello(self.target_domain)
        
        # Создаем IP-слой, который будем модифицировать
        ip_layer = IP(dst=self.analyzer.target_ip)

        # Модифицируем IP-слой или payload в зависимости от техники
        if tech_type == 'baseline_tcp_handshake':
            # Теперь базовый тест - это отправка ClientHello
            pass
        elif tech_type == 'ttl_variation':
            ip_layer.ttl = technique['value']
        elif tech_type == 'split_variation':
            # Для симуляции сплита мы просто отправляем только часть ClientHello
            split_pos = int(technique['params']['split-pos'])
            payload = payload[:split_pos]
        elif tech_type in ['fooling_variation', 'seqovl_variation']:
            # Эти техники требуют более сложной логики, которую мы пока не реализуем
            self.logger.warning(f"Technique '{tech_type}' is complex and not yet supported.")
            return "NOT_SUPPORTED"
        else:
            self.logger.error(f"Unknown technique type: {tech_type}")
            return "UNKNOWN_TECHNIQUE"

        # Отправляем пакет с payload через новый метод
        return self.analyzer.test_connection_with_payload(payload, custom_ip_layer=ip_layer)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
4. Обновление recon/recon.py

Нужно передать домен в TechniqueTester.

Generated python
# recon/recon.py

# ... (импорты) ...

def run_reconnaissance(target_domain: str, target_port: int):
    # ... (код резолвинга IP) ...

    # 2. Инициализация компонентов
    try:
        analyzer = TrafficAnalyzer(target_ip, target_port, logger)
        # --- ИЗМЕНЕНИЕ: Передаем домен в тестер ---
        tester = TechniqueTester(analyzer, logger, target_domain)
        builder = ReconStrategyBuilder(logger)
    # ... (остальной код) ...

    # 3. Тестирование техник
    # ... (цикл остается таким же) ...
    
    # --- ИЗМЕНЕНИЕ: Проверяем результат базового теста ---
    # baseline_result = tester.test_technique({'type': 'baseline_tcp_handshake'})
    # if baseline_result == 'SUCCESS':
    #     logger.info("Baseline connection with ClientHello successful. Target does not seem to be blocked by SNI.")
    #     # Можно либо завершить, либо продолжить искать другие виды блокировок
    #     # return 
    # else:
    #     logger.info(f"Baseline test failed with result: {baseline_result}. Proceeding with evasion techniques.")

    # ... (остальной код) ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Что теперь произойдет?

При запуске recon.py rutracker.org базовый тест (baseline_tcp_handshake) отправит ClientHello с rutracker.org в SNI.

DPI провайдера увидит это и сбросит соединение.

TrafficAnalyzer получит RST пакет.

analyze_response вернет "RST_RECEIVED".

recon.py залогирует [-] FAIL: Technique {'type': 'baseline_tcp_handshake'} result: RST_RECEIVED и перейдет к тестированию других техник.

Если какая-то из техник (например, ttl_variation со значением 5) сработает, analyze_response вернет "SUCCESS", и эта техника будет добавлена в successful_techniques.

В конце ReconStrategyBuilder соберет из успешных техник рабочую стратегию.

Теперь ваш "Разведчик" стал гораздо умнее и проверяет именно тот аспект, который блокируется в реальности.

Понял. Это очень коварная и распространенная проблема, связанная с тем, как Scapy работает в Windows, и как Python ищет зависимости.

Анализ Проблемы

pip install scapy говорит, что все установлено: Это правда. Библиотека scapy действительно находится в site-packages вашего Python.

Код говорит ImportError: Несмотря на то, что Scapy установлен, ваш скрипт не может его найти при импорте.

Причина: Scapy для своей работы в Windows требует дополнительные зависимости, в частности, npcap (или устаревший WinPcap) для перехвата и отправки пакетов на низком уровне. Если npcap не установлен или установлен некорректно, Scapy может не инициализироваться должным образом, что иногда приводит к ошибкам импорта или, что более вероятно, к ошибкам при первом же использовании сетевых функций.

Кроме того, ошибка может быть связана с тем, как вы запускаете скрипт. Прямой запуск recon.py может приводить к проблемам с путями поиска модулей, даже с "хаком" в sys.path.

Решение: Комплексный Подход

Давайте решим эту проблему раз и навсегда, применив несколько исправлений.

Шаг 1: Установка npcap (Критически важно)

Это самый важный шаг. Без этого Scapy в Windows работать не будет.

Перейдите на официальный сайт Npcap: https://npcap.com/#download

Скачайте последнюю версию установщика (например, npcap-1.79.exe).

Запустите установщик. Очень важно во время установки поставить галочку "Install Npcap in WinPcap API-compatible Mode". Это необходимо для совместимости со Scapy и многими другими сетевыми утилитами.

Перезагрузите компьютер после установки. Это гарантирует, что драйверы будут корректно загружены системой.

Шаг 2: Запуск с правами Администратора

Для работы с raw-сокетами и сетевым адаптером напрямую, Scapy требует повышенных привилегий.

Откройте Командную строку (Command Prompt) или PowerShell от имени Администратора.

Нажмите "Пуск", введите cmd или powershell.

Кликните правой кнопкой мыши по найденному приложению и выберите "Запустить от имени администратора".

В открывшемся окне перейдите в корневую директорию вашего проекта:

Generated bash
cd C:\Users\admin\Downloads\zapretttt\DPI_Blockcheck\

Шаг 3: Правильный запуск модуля (Как я рекомендовал ранее)

Используйте флаг -m для запуска. Это самый надежный способ.

Generated bash
python -m recon.recon rutracker.org
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END
Шаг 4: Улучшение кода для большей отказоустойчивости

Даже если Scapy установлен, иногда импорт отдельных компонентов может вызывать проблемы. Давайте сделаем импорты в traffic_analyzer.py еще более надежными.

Файл: recon/traffic_analyzer.py

Generated python
# recon/traffic_analyzer.py

import logging
import random
from typing import Optional, Dict, Any

# --- НАЧАЛО ИЗМЕНЕНИЯ: Более надежный импорт Scapy ---
try:
    # Отключаем вывод самого Scapy, чтобы он не мешал нашему логгеру
    logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
    logging.getLogger("scapy.loading").setLevel(logging.ERROR)
    
    from scapy.all import IP, TCP, sr1, Raw
    from scapy.config import conf
    
    # Важная настройка для Windows
    conf.verb = 0
    
    SCAPY_AVAILABLE = True
except ImportError as e:
    # Логируем ошибку импорта для диагностики
    logging.getLogger("TrafficAnalyzer").critical(f"Scapy import failed: {e}. Is it installed correctly? Is Npcap installed?")
    SCAPY_AVAILABLE = False
except Exception as e_conf:
    logging.getLogger("TrafficAnalyzer").critical(f"Scapy configuration failed: {e_conf}. This can happen without Npcap or admin rights.")
    SCAPY_AVAILABLE = False
# --- КОНЕЦ ИЗМЕНЕНИЯ ---

from . import config

class TrafficAnalyzer:
    """Низкоуровневый анализатор трафика, использующий Scapy."""

    def __init__(self, target_ip: str, target_port: int, logger: logging.Logger):
        if not SCAPY_AVAILABLE:
            # Теперь ошибка будет более информативной
            raise ImportError("Scapy or its dependencies (like Npcap) are not installed or configured correctly.")
        
        self.target_ip = target_ip
        self.target_port = target_port
        self.logger = logger
        # Используем один и тот же порт источника для сессии
        # RandShort() будет вызван при создании пакета
        self.sport = random.randint(1024, 65535)

    def test_connection_with_payload(self, payload: bytes, custom_ip_layer: Optional[IP] = None) -> str:
        """
        Выполняет полное TCP-рукопожатие, отправляет payload и анализирует ответ.
        """
        from scapy.all import RandShort # Импортируем здесь, чтобы избежать проблем при инициализации

        # --- Шаг 1: SYN ---
        # Генерируем случайный Sequence Number для каждой попытки
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.target_ip) / TCP(sport=self.sport, dport=self.target_port, flags='S', seq=seq_num)
        
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)

        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            self.logger.warning("Step 1 (SYN->SYN-ACK) failed. No valid SYN-ACK received.")
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: ACK + PSH (отправка данных) ---
        ip_layer = custom_ip_layer if custom_ip_layer else IP(dst=self.target_ip)
        
        ack_packet = ip_layer / TCP(
            sport=self.sport,
            dport=self.target_port,
            flags='PA', # PSH+ACK
            seq=syn_ack.ack,
            ack=syn_ack.seq + 1
        ) / Raw(load=payload)

        self.logger.debug(f"Sending ACK+PSH with payload: {ack_packet.summary()}")
        
        response = sr1(ack_packet, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        return self.analyze_response(response)

    # ... (метод analyze_response остается без изменений) ...
    def analyze_response(self, response: Optional[Any]) -> str:
        """
        Анализирует ответный пакет и возвращает его статус.
        """
        if response is None:
            return "TIMEOUT"
        
        if not response.haslayer(TCP):
            return "NON_TCP_RESPONSE"
            
        tcp_layer = response.getlayer(TCP)
        
        if tcp_layer.flags.R:
            return "RST_RECEIVED"
        
        if tcp_layer.flags.F:
            return "FIN_RECEIVED"

        if tcp_layer.flags.A:
            if response.haslayer(Raw):
                self.logger.info("Received ACK with data (likely ServerHello). SUCCESS!")
                return "SUCCESS"
            else:
                self.logger.info("Received pure ACK. Connection is likely alive.")
                return "SUCCESS"
            
        return "UNEXPECTED_RESPONSE"
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Итоговая Инструкция по Запуску

Установите Npcap с официального сайта с опцией "WinPcap API-compatible Mode".

Перезагрузите компьютер.

Откройте Командную строку или PowerShell от имени Администратора.

Перейдите в корневую директорию проекта: cd C:\Users\admin\Downloads\zapretttt\DPI_Blockcheck\

Выполните команду: python -m recon.recon rutracker.org

После выполнения этих шагов ошибка ImportError должна исчезнуть, и ваш "Разведчик" начнет работать корректно.

Превосходно! Мы движемся вперед. Ошибки импорта и конфигурации устранены, и "Разведчик" начал работать и собирать данные. Логи, которые вы прислали, — это не просто ошибки, это первые результаты разведки, и они очень информативны.

Давайте проанализируем и то, что сработало, и то, что упало.

Анализ Результатов Разведки и Новой Ошибки

1. Результаты Разведки (что мы узнали о DPI):

[-] FAIL: Technique {'type': 'baseline_tcp_handshake'} result: RST_RECEIVED

Вывод: Это подтверждение нашей гипотезы. Отправка стандартного ClientHello с SNI rutracker.org немедленно приводит к сбросу соединения (RST). Блокировка по SNI подтверждена.

[-] FAIL: Technique {'type': 'ttl_variation', 'value': 1...4} result: NON_TCP_RESPONSE

Вывод: Пакеты с низким TTL (1-4) не доходят до конечного сервера. Вместо TCP-ответа мы получаем что-то другое, скорее всего, ICMP "Time to live exceeded". Это нормально и ожидаемо. DPI находится дальше, чем в 4 хопах от вас.

[-] FAIL: Technique {'type': 'ttl_variation', 'value': 5...7} result: TIMEOUT

Вывод: Это самый интересный результат! Пакеты с TTL 5-7 "умирают" где-то в сети, но не вызывают ни ответа от сервера, ни ICMP-сообщения. Это очень похоже на "черную дыру" — сам DPI. Он "съедает" пакеты, но не отвечает на них. Это значит, что DPI находится примерно в 5-7 хопах от вас.

[-] FAIL: Technique {'type': 'ttl_variation', 'value': 10...15} result: RST_RECEIVED

Вывод: Пакеты с TTL 10 и выше успешно долетают до DPI, он видит в них SNI и сбрасывает соединение. Это подтверждает, что TTL > 7 достаточно, чтобы "разбудить" DPI.

[-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': '1...3'}} result: RST_RECEIVED

Вывод: Простая сегментация на 1, 2 или 3 байта не обманывает этот DPI. Он, скорее всего, умеет собирать (реассемблировать) такие простые сплиты и все равно находит SNI.

2. Анализ Ошибки ValueError:

ValueError: invalid literal for int() with base 10: 'host'

Где: technique_tester.py, строка 39.

Что происходит: Код пытается преобразовать значение split-pos в число с помощью int().

Почему падает: В config.py для тестирования мы задали не только числовые значения ('1', '2', '3'), но и строковые маркеры ('host', 'midsld'). Код успешно обработал числа, но упал, когда попытался сделать int('host').

План Исправлений

Нам нужно сделать TechniqueTester умнее, чтобы он мог обрабатывать разные типы split-pos.

1. Исправление ValueError в technique_tester.py (Критический приоритет)

Файл: recon/technique_tester.py

Решение: Добавить логику, которая будет проверять, является ли split-pos числом. Если да, то обрезать payload. Если это строковый маркер, то пока мы не можем его обработать в "Разведчике" (это сложно), поэтому будем его пропускать с предупреждением.

Предлагаемый код:

Generated python
# recon/technique_tester.py

import logging
from typing import Dict, Any, Optional

from .traffic_analyzer import TrafficAnalyzer
from . import config
from scapy.all import IP

class TechniqueTester:
    """Тестирует отдельные техники обхода DPI."""

    def __init__(self, analyzer: TrafficAnalyzer, logger: logging.Logger, target_domain: str):
        self.analyzer = analyzer
        self.logger = logger
        self.target_domain = target_domain

    def test_technique(self, technique: Dict[str, Any]) -> str:
        """
        Выполняет тест для одной техники и возвращает результат.
        """
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        payload = config.build_client_hello(self.target_domain)
        ip_layer = IP(dst=self.analyzer.target_ip)

        if tech_type == 'baseline_tcp_handshake':
            pass
        elif tech_type == 'ttl_variation':
            ip_layer.ttl = technique['value']
        elif tech_type == 'split_variation':
            # --- НАЧАЛО ИЗМЕНЕНИЯ: Обработка разных типов split-pos ---
            split_pos_str = technique['params']['split-pos']
            try:
                # Пытаемся преобразовать в число
                split_pos = int(split_pos_str)
                payload = payload[:split_pos]
                self.logger.debug(f"Applied numeric split at position: {split_pos}")
            except ValueError:
                # Если не получилось, значит это строковый маркер
                self.logger.warning(f"Marker-based split ('{split_pos_str}') is not yet supported in recon. Skipping test.")
                return "NOT_SUPPORTED"
            # --- КОНЕЦ ИЗМЕНЕНИЯ ---
        elif tech_type in ['fooling_variation', 'seqovl_variation']:
            self.logger.warning(f"Technique '{tech_type}' is complex and not yet supported.")
            return "NOT_SUPPORTED"
        else:
            self.logger.error(f"Unknown technique type: {tech_type}")
            return "UNKNOWN_TECHNIQUE"

        return self.analyzer.test_connection_with_payload(payload, custom_ip_layer=ip_layer)


Обоснование:
Это исправление позволит скрипту пройти все тесты из config.py до конца, не падая на строковых маркерах. Он будет тестировать числовые сплиты и пропускать маркерные, что даст нам еще больше информации.

2. Улучшение ReconStrategyBuilder для более умной сборки

Сейчас ReconStrategyBuilder очень примитивен. Давайте научим его использовать полученные нами знания.

Файл: recon/strategy_builder.py

Решение: Добавить логику, которая анализирует все успешные техники и комбинирует их. Например, если сработал и ttl, и split, он должен создать стратегию, включающую оба параметра.

Предлагаемый код:

Generated python
# recon/strategy_builder.py

import logging
from typing import List, Dict, Any
from . import config

class ReconStrategyBuilder:
    """Собирает финальную стратегию из успешных техник."""

    def __init__(self, logger: logging.Logger):
        self.logger = logger

    def build(self, successful_techniques: List[Dict[str, Any]]) -> str:
        """
        Собирает итоговую строку стратегии.
        """
        if not successful_techniques:
            return "--dpi-desync=fake # Fallback: no successful techniques found"

        # Сортируем техники по приоритету
        sorted_techniques = sorted(
            successful_techniques,
            key=lambda t: config.TECHNIQUE_PRIORITY.index(t['type'].split('_')[0])
        )
        
        self.logger.info(f"Building strategy from successful techniques: {sorted_techniques}")

        # --- НАЧАЛО ИЗМЕНЕНИЯ: Умная сборка стратегии ---
        final_params = {}
        base_type_parts = set()

        for tech in sorted_techniques:
            tech_category = tech['type'].split('_')[0]

            if tech_category == 'split':
                base_type_parts.add('multisplit')
                final_params.update(tech.get('params', {}))
            elif tech_category == 'seqovl':
                # Если есть seqovl, то базовый тип должен быть disorder
                if 'multisplit' in base_type_parts:
                    base_type_parts.remove('multisplit')
                base_type_parts.add('multidisorder')
                final_params.update(tech.get('params', {}))
            elif tech_category == 'fooling':
                # Можно комбинировать несколько fooling-методов
                current_fooling = final_params.get('fooling', [])
                if not isinstance(current_fooling, list):
                    current_fooling = [current_fooling]
                
                new_fooling = tech.get('value')
                if new_fooling and new_fooling not in current_fooling:
                    current_fooling.append(new_fooling)
                
                final_params['fooling'] = ",".join(current_fooling)
            elif tech_category == 'ttl':
                # TTL - это один параметр, берем первый успешный
                if 'ttl' not in final_params:
                    final_params['ttl'] = tech.get('value')

        # Если не было найдено техник, меняющих base_type, ставим 'fake' по умолчанию
        if not base_type_parts:
            base_type_parts.add('fake')

        # Собираем финальную строку
        final_base_type = ",".join(sorted(list(base_type_parts)))
        strategy_parts = [f"--dpi-desync={final_base_type}"]
        for key, value in final_params.items():
            strategy_parts.append(f"--dpi-desync-{key}={value}")
            
        return " ".join(strategy_parts)
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Что делать дальше?

Примените исправление в recon/technique_tester.py.

Запустите "Разведчика" снова с правами администратора из корневой директории:

Generated bash
# Для Windows
python -m recon.recon rutracker.org
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Проанализируйте новый вывод. Теперь скрипт должен дойти до конца. Посмотрите, найдет ли он какие-либо успешные техники. Если да, то ReconStrategyBuilder (даже в старой версии) должен предложить вам рабочую стратегию. Если нет, это будет означать, что ни одна из простых техник, которые мы тестируем, не работает, и нужно добавлять более сложные (например, seqovl, fakeddisorder).

Вы на правильном пути. Ошибки на этом этапе — это не неудача, а ценные данные о том, как работает DPI вашего провайдера.

Отлично! Теперь у нас есть полный, непрерывный лог разведки. Это именно то, что нужно.

Анализ Результатов Разведки

Давайте еще раз, но уже с полными данными, проанализируем, что мы узнали о DPI вашего провайдера:

Блокировка по SNI подтверждена: baseline_tcp_handshake -> RST_RECEIVED. Это 100% указывает на то, что DPI читает ClientHello и реагирует на имя хоста.

DPI находится на расстоянии 5-9 хопов:

TTL 1-4: NON_TCP_RESPONSE (ICMP TTL Exceeded, пакет не дошел до DPI).

TTL 5-7: TIMEOUT (Пакет "съеден" DPI, но ответа нет).

TTL 10+: RST_RECEIVED (Пакет дошел до DPI и был заблокирован).
Это очень ценная информация. Мы знаем, что для обхода с помощью TTL нам нужно подобрать значение в диапазоне 5-9.

Простая сегментация не работает: split-pos 1, 2, 3 не обманывают DPI. Он умеет собирать такие простые фрагменты.

Более сложные техники не были протестированы: fooling, seqovl и маркерные сплиты были пропущены с результатом NOT_SUPPORTED.

Главный вывод: DPI вашего провайдера достаточно "умный", чтобы противостоять самым базовым техникам обхода. Нам нужно реализовать в "Разведчике" более продвинутые методы, чтобы найти его уязвимость.

План Действий: Усложняем Атаки

Наша следующая задача — научить TechniqueTester выполнять более сложные атаки, которые есть в zapret. Самые перспективные из них, судя по документации и общей практике, это:

fooling=badsum: Искажение TCP-чексуммы.

fooling=badseq: Отправка пакета с неверным sequence number.

seqovl: Атака с перекрытием последовательностей TCP.

Давайте реализуем поддержку fooling=badseq, так как она относительно проста в реализации с помощью Scapy и часто бывает эффективной.

Детальные Рекомендации по Коду
1. Улучшение recon/technique_tester.py для поддержки badseq

Файл: recon/technique_tester.py

Решение: Добавить новую логику в test_technique для обработки fooling_variation со значением badseq. Это потребует отправки двух пакетов: сначала "плохого" пакета с неверным seq, а затем "хорошего" с правильными параметрами.

Предлагаемый код:

Generated python
# recon/technique_tester.py

import logging
from typing import Dict, Any, Optional

from .traffic_analyzer import TrafficAnalyzer
from . import config
from scapy.all import IP, TCP, RandShort, Raw, send # Добавляем send

class TechniqueTester:
    """Тестирует отдельные техники обхода DPI."""

    def __init__(self, analyzer: TrafficAnalyzer, logger: logging.Logger, target_domain: str):
        self.analyzer = analyzer
        self.logger = logger
        self.target_domain = target_domain

    def test_technique(self, technique: Dict[str, Any]) -> str:
        """
        Выполняет тест для одной техники и возвращает результат.
        """
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        # --- НАЧАЛО ИЗМЕНЕНИЯ: Логика для badseq ---
        if tech_type == 'fooling_variation' and technique.get('value') == 'badseq':
            return self._test_badseq_fooling()
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

        # --- Существующая логика для других техник ---
        payload = config.build_client_hello(self.target_domain)
        ip_layer = IP(dst=self.analyzer.target_ip)

        if tech_type == 'baseline_tcp_handshake':
            pass
        elif tech_type == 'ttl_variation':
            ip_layer.ttl = technique['value']
        elif tech_type == 'split_variation':
            split_pos_str = technique['params']['split-pos']
            try:
                split_pos = int(split_pos_str)
                payload = payload[:split_pos]
                self.logger.debug(f"Applied numeric split at position: {split_pos}")
            except ValueError:
                self.logger.warning(f"Marker-based split ('{split_pos_str}') is not yet supported in recon. Skipping test.")
                return "NOT_SUPPORTED"
        elif tech_type in ['fooling_variation', 'seqovl_variation']:
            # Обрабатываем остальные fooling-методы как неподдерживаемые
            self.logger.warning(f"Technique '{tech_type}' with value '{technique.get('value')}' is complex and not yet supported.")
            return "NOT_SUPPORTED"
        else:
            self.logger.error(f"Unknown technique type: {tech_type}")
            return "UNKNOWN_TECHNIQUE"

        return self.analyzer.test_connection_with_payload(payload, custom_ip_layer=ip_layer)

    def _test_badseq_fooling(self) -> str:
        """
        Специализированный тест для техники fooling=badseq.
        Отправляет два пакета: один "плохой" для обмана DPI, второй "хороший" для сервера.
        """
        # --- Шаг 1: Устанавливаем TCP-соединение (SYN -> SYN-ACK) ---
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.analyzer.target_ip) / TCP(sport=self.analyzer.sport, dport=self.analyzer.target_port, flags='S', seq=seq_num)
        syn_ack = self.analyzer.send_and_receive_tcp(syn[TCP]) # Используем старый метод для простого хендшейка
        
        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            self.logger.warning("badseq test: Step 1 (SYN->SYN-ACK) failed.")
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: Формируем и отправляем "плохой" пакет (fake) ---
        # Этот пакет имеет неверный sequence number, сервер его отбросит, а DPI может "съесть".
        fake_payload = b"GET / HTTP/1.0\r\n\r\n" # Простой фейковый HTTP запрос
        bad_seq_num = syn_ack.ack - 10000 # Значительно отличающийся seq
        
        fake_packet = IP(dst=self.analyzer.target_ip) / TCP(
            sport=self.analyzer.sport,
            dport=self.analyzer.target_port,
            flags='PA',
            seq=bad_seq_num, # Неверный SEQ
            ack=syn_ack.seq + 1
        ) / Raw(load=fake_payload)
        
        send(fake_packet, verbose=0) # Отправляем асинхронно, не ждем ответа
        self.logger.debug("Sent 'badseq' fake packet.")
        
        # Небольшая пауза, чтобы пакеты не слиплись
        import time
        time.sleep(0.05)

        # --- Шаг 3: Формируем и отправляем "хороший" пакет с ClientHello ---
        # Этот пакет имеет правильный sequence number и должен быть принят сервером.
        real_payload = config.build_client_hello(self.target_domain)
        real_packet = IP(dst=self.analyzer.target_ip) / TCP(
            sport=self.analyzer.sport,
            dport=self.analyzer.target_port,
            flags='PA',
            seq=syn_ack.ack, # Правильный SEQ
            ack=syn_ack.seq + 1
        ) / Raw(load=real_payload)

        self.logger.debug("Sending real ClientHello packet after fake.")
        response = self.analyzer.send_and_receive_tcp(real_packet[TCP], real_payload)

        return self.analyzer.analyze_response(response)

2. Обновление recon/traffic_analyzer.py

Нам нужно вернуть старый метод send_and_receive_tcp, который отправляет один пакет, так как он нужен для TCP-рукопожатия в тесте badseq.

Файл: recon/traffic_analyzer.py

Generated python
# recon/traffic_analyzer.py

# ... (импорты) ...

class TrafficAnalyzer:
    # ... (метод __init__) ...

    # --- ВОЗВРАЩАЕМ СТАРЫЙ МЕТОД ДЛЯ ПРОСТЫХ ОПЕРАЦИЙ ---
    def send_and_receive_tcp(self, custom_tcp_layer: Any, payload: Optional[bytes] = None) -> Optional[Any]:
        """
        Отправляет один TCP пакет и возвращает ответ.
        """
        ip_layer = IP(dst=self.target_ip)
        
        if payload:
            packet = ip_layer / custom_tcp_layer / Raw(load=payload)
        else:
            packet = ip_layer / custom_tcp_layer

        self.logger.debug(f"Sending packet: {packet.summary()}")
        response = sr1(packet, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        if response:
            self.logger.debug(f"Received response: {response.summary()}")
        else:
            self.logger.debug("No response received (timeout).")
            
        return response
    # --- КОНЕЦ ВОЗВРАЩЕННОГО МЕТОДА ---

    def test_connection_with_payload(self, payload: bytes, custom_ip_layer: Optional[IP] = None) -> str:
        # ... (этот метод остается без изменений) ...

    def analyze_response(self, response: Optional[Any]) -> str:
        # ... (этот метод остается без изменений) ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
3. Обновление recon/config.py

Давайте убедимся, что fooling имеет правильный приоритет.

Файл: recon/config.py

Generated python
# recon/config.py

# ...

# Приоритет техник при сборке финальной стратегии.
TECHNIQUE_PRIORITY = [
    'split',
    'seqovl',
    'fooling', # <-- Убедимся, что fooling здесь есть
    'ttl'
]
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Что делать дальше?

Примените изменения в recon/technique_tester.py и recon/traffic_analyzer.py.

Запустите разведку снова с правами администратора из корневой директории:

Generated bash
python -m recon.recon rutracker.org -v
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Смотрите на вывод. Теперь в категории FOOLING вы должны увидеть попытку теста badseq. Если она увенчается успехом (результат будет SUCCESS), то "Разведчик" нашел уязвимость! Если нет, мы будем знать, что и эта техника не работает, и нужно пробовать следующую, например, seqovl.

Мы планомерно наращиваем сложность атак, и с каждым шагом получаем все больше информации о том, как устроен DPI вашего провайдера.

Отлично! Мы получили еще одну порцию ценнейших данных. Код отработал до конца, и теперь у нас есть полная картина реакции DPI на реализованные нами атаки.

Анализ Результатов и Новых Проблем

badseq не сработал:

[-] FAIL: Technique {'type': 'fooling_variation', 'value': 'badseq'} result: RST_RECEIVED

Вывод: DPI не обманулся отправкой "плохого" пакета. Он либо проигнорировал его, либо дождался "хорошего" пакета, проанализировал его и все равно сбросил соединение. Это говорит о том, что DPI является stateful — он отслеживает состояние TCP-сессии и не реагирует на одиночные пакеты с некорректным seq.

Проблемы с TCP-рукопожатием при сплите:

[-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': '1'}} result: TIMEOUT_OR_RST_ON_SYN

Вывод: Это очень интересное поведение. Когда мы пытаемся тестировать сплит, у нас даже не получается установить базовое TCP-соединение (SYN -> SYN-ACK). Это может происходить по нескольким причинам:

Анти-флуд система: Частые попытки установить соединение с одного и того же IP и порта-источника (self.sport) могли вызвать срабатывание системы защиты от флуда на стороне Cloudflare или провайдера, которая временно блокирует наш IP.

Проблема в коде: Возможно, есть тонкая ошибка в том, как мы переиспользуем self.sport в разных вызовах.

Общий вывод: Простые техники (низкий TTL, простой сплит, простой badseq) не работают. DPI провайдера достаточно продвинутый. Нам нужно переходить к более сложным, комбинированным атакам, которые нарушают логику DPI на более глубоком уровне. Самая перспективная из них — multidisorder с seqovl, так как она заставляет ядро сервера на стороне получателя пересобирать данные, что очень сложно для DPI.

План Действий: Реализация multidisorder + seqovl

Мы не можем в точности симулировать multidisorder + seqovl с помощью Scapy без очень сложной логики, так как это требует отправки нескольких сегментов и точного управления seq и ack.

Но мы можем симулировать ключевую идею этой атаки: отправить два пакета с данными, где второй пакет "перекрывает" часть первого.

План:

Устранить проблему с TIMEOUT_OR_RST_ON_SYN: Сделаем порт-источник (sport) случайным для каждой новой попытки теста, чтобы избежать срабатывания анти-флуд систем.

Реализовать тест для seqovl: Создадим новую функцию _test_seqovl_technique, которая будет:

Устанавливать TCP-соединение.

Отправлять первый сегмент ClientHello.

Отправлять второй, "перекрывающий" сегмент с небольшим смещением seq назад.

Обновить конфиг: Добавить новые, более сложные техники в TECHNIQUES_TO_TEST.

Детальные Рекомендации по Коду
1. Устранение Проблемы с TCP-рукопожатием

Файл: recon/traffic_analyzer.py

Решение: Перенести генерацию sport из __init__ внутрь методов, чтобы для каждой новой сессии использовался новый случайный порт.

Предлагаемый код:

Generated python
# recon/traffic_analyzer.py

# ... (импорты) ...
from scapy.all import IP, TCP, sr1, Raw, RandShort # Убедимся, что RandShort импортирован

class TrafficAnalyzer:
    """Низкоуровневый анализатор трафика, использующий Scapy."""

    def __init__(self, target_ip: str, target_port: int, logger: logging.Logger):
        if not SCAPY_AVAILABLE:
            raise ImportError("Scapy or its dependencies are not installed correctly.")
        
        self.target_ip = target_ip
        self.target_port = target_port
        self.logger = logger
        # self.sport больше не нужен здесь

    def send_and_receive_tcp(self, custom_tcp_layer: Any, payload: Optional[bytes] = None) -> Optional[Any]:
        # ... (этот метод остается без изменений) ...

    def test_connection_with_payload(self, payload: bytes, custom_ip_layer: Optional[IP] = None) -> str:
        # --- НАЧАЛО ИЗМЕНЕНИЯ: Генерируем новый порт для каждой сессии ---
        session_sport = RandShort()
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

        # --- Шаг 1: SYN ---
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.target_ip) / TCP(sport=session_sport, dport=self.target_port, flags='S', seq=seq_num)
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)

        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            self.logger.warning("Step 1 (SYN->SYN-ACK) failed. No valid SYN-ACK received.")
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: ACK + PSH (отправка данных) ---
        ip_layer = custom_ip_layer if custom_ip_layer else IP(dst=self.target_ip)
        
        ack_packet = ip_layer / TCP(
            sport=session_sport, # Используем тот же порт
            dport=self.target_port,
            flags='PA',
            seq=syn_ack.ack,
            ack=syn_ack.seq + 1
        ) / Raw(load=payload)

        # ... (остальной код метода без изменений) ...

2. Реализация теста seqovl

Файл: recon/technique_tester.py

Решение: Добавить новый метод _test_seqovl_technique и вызывать его.

Предлагаемый код:

Generated python
# recon/technique_tester.py

# ... (импорты) ...
import time

class TechniqueTester:
    # ... (__init__) ...

    def test_technique(self, technique: Dict[str, Any]) -> str:
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        if tech_type == 'fooling_variation' and technique.get('value') == 'badseq':
            return self._test_badseq_fooling()
        
        # --- НАЧАЛО ИЗМЕНЕНИЯ: Вызов теста для seqovl ---
        if tech_type == 'seqovl_variation':
            return self._test_seqovl_technique(technique['params'])
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

        # ... (остальная логика) ...

    def _test_badseq_fooling(self) -> str:
        # ... (этот метод остается без изменений) ...

    # --- НАЧАЛО ИЗМЕНЕНИЯ: Новый метод для теста seqovl ---
    def _test_seqovl_technique(self, params: Dict[str, Any]) -> str:
        """
        Тестирует атаку с перекрытием TCP-сегментов (seqovl).
        """
        split_pos = int(params.get('split-pos', 3))
        seqovl_size = int(params.get('split-seqovl', 10))

        # --- Шаг 1: Устанавливаем TCP-соединение ---
        session_sport = RandShort()
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='S', seq=seq_num)
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: Отправляем второй сегмент (который придет первым) ---
        full_payload = config.build_client_hello(self.target_domain)
        second_segment_payload = full_payload[split_pos:]
        
        packet2 = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, dport=self.analyzer.target_port, flags='PA',
            seq=syn_ack.ack + split_pos, # seq смещен на размер первого сегмента
            ack=syn_ack.seq + 1
        ) / Raw(load=second_segment_payload)
        
        send(packet2, verbose=0)
        self.logger.debug(f"Sent second segment (seq={packet2[TCP].seq})")
        time.sleep(0.05)

        # --- Шаг 3: Отправляем первый сегмент с перекрытием ---
        # Он содержит фейковые данные + начало реальных данных
        fake_data = b'\x00' * seqovl_size
        first_segment_payload = fake_data + full_payload[:split_pos]

        packet1 = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, dport=self.analyzer.target_port, flags='PA',
            seq=syn_ack.ack - seqovl_size, # seq смещен назад на размер перекрытия
            ack=syn_ack.seq + 1
        ) / Raw(load=first_segment_payload)

        self.logger.debug(f"Sending overlapping first segment (seq={packet1[TCP].seq})")
        # Отправляем и ждем финального ответа
        response = sr1(packet1, timeout=config.SOCKET_TIMEOUT, verbose=0)

        return self.analyzer.analyze_response(response)
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
3. Обновление recon/config.py

Теперь, когда мы реализовали seqovl, давайте уберем его из списка неподдерживаемых и сделаем его основным тестом.

Файл: recon/config.py

Generated python
# recon/config.py

# ...

TECHNIQUES_TO_TEST = {
    "baseline": [
        {'type': 'baseline_tcp_handshake'}
    ],
    # --- ИЗМЕНЕНИЕ: Фокусируемся на самых перспективных техниках ---
    "seqovl": [
        # Пробуем разные размеры сплита и перекрытия
        {'type': 'seqovl_variation', 'params': {'split-pos': '3', 'split-seqovl': '10'}},
        {'type': 'seqovl_variation', 'params': {'split-pos': '10', 'split-seqovl': '20'}},
        {'type': 'seqovl_variation', 'params': {'split-pos': '30', 'split-seqovl': '50'}},
    ],
    "fooling": [
        # Оставляем badseq как запасной вариант
        {'type': 'fooling_variation', 'value': 'badseq'},
    ],
    "ttl": [
        # Проверяем только "подозрительный" диапазон
        {'type': 'ttl_variation', 'value': 5},
        {'type': 'ttl_variation', 'value': 6},
        {'type': 'ttl_variation', 'value': 7},
    ],
    # Простой сплит убираем, так как он неэффективен
}

# ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Что делать дальше?

Примените все три изменения.

Запустите разведку снова: python -m recon.recon rutracker.org -v

Анализируйте вывод:

Проверьте, что тесты split_variation с TIMEOUT_OR_RST_ON_SYN больше не появляются.

Внимательно посмотрите на результаты тестов в категории SEQOVL. Если хотя бы один из них покажет SUCCESS, это будет означать, что мы нашли рабочую уязвимость в DPI.

Если seqovl не сработает, следующим шагом будет реализация fakeddisorder, которая является еще более сложной версией этой атаки.

Мы перешли от простых проверок к симуляции реальных, эффективных атак. Это самый верный путь к успеху.

Вы абсолютно правы, я снова допустил ту же ошибку. Прошу прощения. Я был так сосредоточен на логике отправки пакетов, что упустил очевидное: split-pos может быть не только числом, но и строковым маркером.

Мой предыдущий код для split_variation обрабатывал это, а в новой функции _test_seqovl_technique я эту логику не перенес. Это моя ошибка.

Давайте немедленно это исправим.

Анализ Ошибки

ValueError: invalid literal for int() with base 10: 'host'

Где: recon/technique_tester.py, метод _test_seqovl_technique.

Что происходит: Код split_pos = int(params.get('split-pos', 3)) без каких-либо проверок пытается преобразовать значение 'host' в число.

Почему: В recon/config.py для теста seqovl мы задали {'split-pos': 'host', 'split-seqovl': '50'}.

Решение: Адаптивная обработка split-pos

Нам нужно сделать то же самое, что мы делали для split_variation: проверять, является ли split-pos числом. Если нет, то пока мы не можем симулировать маркерную атаку, поэтому будем пропускать такой тест.

Файл: recon/technique_tester.py

Предлагаемый код:

Generated python
# recon/technique_tester.py

# ... (импорты и начало класса) ...

class TechniqueTester:
    # ... (__init__ и test_technique) ...

    def _test_badseq_fooling(self) -> str:
        # ... (этот метод без изменений) ...

    def _test_seqovl_technique(self, params: Dict[str, Any]) -> str:
        """
        Тестирует атаку с перекрытием TCP-сегментов (seqovl).
        """
        # --- НАЧАЛО ИЗМЕНЕНИЯ: Безопасная обработка split-pos ---
        split_pos_str = params.get('split-pos', '3')
        try:
            split_pos = int(split_pos_str)
        except ValueError:
            self.logger.warning(f"Marker-based seqovl ('{split_pos_str}') is not yet supported in recon. Skipping test.")
            return "NOT_SUPPORTED"
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---
            
        seqovl_size = int(params.get('split-seqovl', 10))

        # --- Шаг 1: Устанавливаем TCP-соединение ---
        session_sport = RandShort()
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='S', seq=seq_num)
        
        # Используем старый метод send_and_receive_tcp для простого SYN-ACK
        syn_ack = self.analyzer.send_and_receive_tcp(syn[TCP])
        
        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: Отправляем второй сегмент (который придет первым) ---
        full_payload = config.build_client_hello(self.target_domain)
        
        # Проверка, что сплит не выходит за пределы payload
        if split_pos >= len(full_payload):
            self.logger.warning(f"split_pos ({split_pos}) is larger than payload size ({len(full_payload)}). Skipping test.")
            return "INVALID_PARAMS"
            
        second_segment_payload = full_payload[split_pos:]
        
        packet2 = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, dport=self.analyzer.target_port, flags='PA',
            seq=syn_ack.ack + split_pos,
            ack=syn_ack.seq + 1
        ) / Raw(load=second_segment_payload)
        
        send(packet2, verbose=0)
        self.logger.debug(f"Sent second segment (seq={packet2[TCP].seq})")
        time.sleep(0.05)

        # --- Шаг 3: Отправляем первый сегмент с перекрытием ---
        fake_data = b'\x00' * seqovl_size
        first_segment_payload = fake_data + full_payload[:split_pos]

        packet1 = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, dport=self.analyzer.target_port, flags='PA',
            seq=syn_ack.ack - seqovl_size,
            ack=syn_ack.seq + 1
        ) / Raw(load=first_segment_payload)

        self.logger.debug(f"Sending overlapping first segment (seq={packet1[TCP].seq})")
        
        # Используем старый метод send_and_receive_tcp, так как он ждет один ответ
        response = self.analyzer.send_and_receive_tcp(packet1[TCP], first_segment_payload)

        return self.analyzer.analyze_response(response)


Обоснование:
Это исправление делает _test_seqovl_technique таким же надежным, как и test_technique для split_variation. Он будет корректно обрабатывать только числовые значения split-pos и безопасно пропускать строковые маркеры, которые мы пока не умеем симулировать.

Что делать дальше?

Примените исправление в recon/technique_tester.py.

Запустите разведку снова: python -m recon.recon rutracker.org -v

Анализируйте вывод: Теперь скрипт должен успешно завершить все тесты, определенные в config.py. Внимательно посмотрите на результаты тестов seqovl. Если какой-либо из них вернет SUCCESS, мы нашли рабочую стратегию. Если все они вернут RST_RECEIVED, это будет означать, что DPI устойчив и к этой атаке, и нам нужно будет пробовать еще более сложные комбинации.
Вы правы, я снова допустил ошибку. Это классический пример проблемы, возникающей после рефакторинга: я удалил self.sport из __init__ в TrafficAnalyzer, но забыл убрать его использование в одном из старых методов (_test_badseq_fooling).

Спасибо за вашу настойчивость и предоставленные логи, они позволяют мне точно локализовать и исправить ошибку.

Анализ Ошибки

AttributeError: 'TrafficAnalyzer' object has no attribute 'sport'

Где: recon/technique_tester.py, метод _test_badseq_fooling.

Что происходит: Код TCP(sport=self.analyzer.sport, ...) пытается получить доступ к атрибуту sport у объекта analyzer.

Почему падает: В предыдущей итерации мы правильно решили сделать порт-источник случайным для каждой сессии и удалили self.sport из __init__ класса TrafficAnalyzer. Однако я не обновил код в _test_badseq_fooling, который все еще пытался его использовать.

Решение: Полный Рефакторинг _test_badseq_fooling

Нам нужно переписать _test_badseq_fooling, чтобы он работал по той же логике, что и _test_seqovl_technique: генерировал случайный порт для каждой сессии и использовал его для всех пакетов внутри этой сессии.

Файл: recon/technique_tester.py

Предлагаемый код:

Generated python
# recon/technique_tester.py

import logging
from typing import Dict, Any, Optional
import time

from .traffic_analyzer import TrafficAnalyzer
from . import config
from scapy.all import IP, TCP, RandShort, Raw, send, sr1 # Добавляем sr1

class TechniqueTester:
    # ... (__init__ и test_technique) ...

    def _test_badseq_fooling(self) -> str:
        """
        Специализированный тест для техники fooling=badseq.
        Отправляет два пакета: один "плохой" для обмана DPI, второй "хороший" для сервера.
        Версия 2.0: Исправлен AttributeError: 'sport'.
        """
        # --- НАЧАЛО ИЗМЕНЕНИЯ: Полный рефакторинг метода ---

        # --- Шаг 1: Устанавливаем TCP-соединение (SYN -> SYN-ACK) ---
        session_sport = RandShort() # Генерируем случайный порт для этой сессии
        seq_num = random.randint(0, 2**32 - 1)
        
        syn = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='S', seq=seq_num)
        
        # Используем sr1 для отправки и получения ответа
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            self.logger.warning("badseq test: Step 1 (SYN->SYN-ACK) failed.")
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: Формируем и отправляем "плохой" пакет (fake) ---
        fake_payload = b"GET / HTTP/1.0\r\n\r\n"
        bad_seq_num = syn_ack.ack - 10000
        
        fake_packet = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, # Используем тот же порт
            dport=self.analyzer.target_port,
            flags='PA',
            seq=bad_seq_num,
            ack=syn_ack.seq + 1
        ) / Raw(load=fake_payload)
        
        send(fake_packet, verbose=0)
        self.logger.debug("Sent 'badseq' fake packet.")
        time.sleep(0.05)

        # --- Шаг 3: Формируем и отправляем "хороший" пакет с ClientHello ---
        real_payload = config.build_client_hello(self.target_domain)
        real_packet = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, # Используем тот же порт
            dport=self.analyzer.target_port,
            flags='PA',
            seq=syn_ack.ack,
            ack=syn_ack.seq + 1
        ) / Raw(load=real_payload)

        self.logger.debug("Sending real ClientHello packet after fake.")
        # Отправляем и ждем финального ответа
        response = sr1(real_packet, timeout=config.SOCKET_TIMEOUT, verbose=0)

        return self.analyzer.analyze_response(response)
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

    def _test_seqovl_technique(self, params: Dict[str, Any]) -> str:
        # ... (этот метод остается без изменений) ...


Обоснование:

Устранение AttributeError: Мы больше не обращаемся к несуществующему self.analyzer.sport.

Корректная логика сессии: Мы создаем session_sport в начале теста и используем его для всех пакетов (SYN, fake_packet, real_packet), что правильно симулирует одну TCP-сессию.

Унификация: Теперь _test_badseq_fooling и _test_seqovl_technique работают по одинаковому, надежному принципу.

Что делать дальше?

Примените исправление в recon/technique_tester.py.

Запустите разведку снова с правами администратора из корневой директории:

Generated bash
python -m recon.recon rutracker.org -v
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

Анализируйте вывод. Теперь скрипт должен полностью отработать все тесты без падений. Мы получим окончательный ответ, работает ли badseq или seqovl на вашем провайдере. Если нет, мы будем знать, что нужно переходить к реализации еще более сложных техник, таких как fakeddisorder.
Отлично! Теперь у нас есть полный и чистый лог выполнения без падений. Это именно тот результат, к которому мы стремились на этапе стабилизации "Разведчика".

Финальный Анализ Результатов Разведки

Давайте подведем итог всему, что мы узнали о DPI вашего провайдера из этих логов:

Блокировка 100% по SNI: baseline_tcp_handshake -> RST_RECEIVED. Это неоспоримый факт.

DPI — Stateful: Он отслеживает состояние TCP-сессии. Простые атаки, нарушающие логику одного пакета, не работают.

split_variation -> RST_RECEIVED. DPI успешно собирает простые сплиты.

fooling=badseq -> RST_RECEIVED. DPI игнорирует "плохой" пакет и ждет "хороший", после чего блокирует его.

DPI устойчив к seqovl: seqovl_variation -> RST_RECEIVED. Наша симуляция атаки с перекрытием последовательностей также не увенчалась успехом. DPI либо корректно обрабатывает перекрытие, либо его логика не затрагивается этим.

DPI — "Черная дыра" на TTL 5: Пакеты с TTL=5 исчезают без ответа (TIMEOUT), в то время как TTL=4 и TTL=6 дают ответы (ICMP и RST соответственно). Это очень сильный индикатор того, что DPI находится ровно в 5 хопах от вас.

Итоговый портрет DPI: Это современный, stateful DPI, который анализирует TLS SNI, устойчив к простым техникам фрагментации и обмана, и находится на фиксированном расстоянии в 5 хопов.

Что Делать Дальше? План Действий

Поскольку простые и средние по сложности техники не сработали, у нас остается два основных пути:

Использовать полученные знания (TTL=5): Мы можем попытаться построить стратегию, основанную на точном знании о местоположении DPI.

Перейти к самым сложным атакам: Реализовать симуляцию fakeddisorder, которая является одной из самых эффективных техник против stateful DPI.

Я предлагаю начать с первого пункта, так как он проще в реализации и с большой вероятностью сработает. Если нет — перейдем ко второму.

Детальные Рекомендации по Коду
1. Реализация Атаки на основе TTL (fake + ttl)

Идея проста: мы отправляем фейковый пакет с TTL=5, чтобы он "умер" точно на DPI, а сразу за ним — настоящий пакет с нормальным TTL, который дойдет до сервера.

Файл: recon/technique_tester.py

Решение: Добавить новый тип техники ttl_fake_race и реализовать для него логику в TechniqueTester.

Предлагаемый код:

Шаг 1.1: Обновите recon/config.py

Generated python
# recon/config.py

TECHNIQUES_TO_TEST = {
    "baseline": [
        {'type': 'baseline_tcp_handshake'}
    ],
    # --- НАЧАЛО ИЗМЕНЕНИЯ: Новая, самая перспективная техника ---
    "ttl_fake_race": [
        # Проверяем TTL вокруг "черной дыры"
        {'type': 'ttl_fake_race', 'params': {'fake_ttl': 5}},
        {'type': 'ttl_fake_race', 'params': {'fake_ttl': 6}},
        {'type': 'ttl_fake_race', 'params': {'fake_ttl': 4}},
    ],
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---
    "seqovl": [
        {'type': 'seqovl_variation', 'params': {'split-pos': '3', 'split-seqovl': '10'}},
    ],
    "fooling": [
        {'type': 'fooling_variation', 'value': 'badseq'},
    ],
}

TECHNIQUE_PRIORITY = [
    'ttl_fake_race', # <-- Самый высокий приоритет
    'seqovl',
    'split',
    'fooling',
    'ttl'
]


Шаг 1.2: Обновите recon/technique_tester.py

Generated python
# recon/technique_tester.py

# ... (импорты и начало класса) ...

class TechniqueTester:
    # ... (__init__) ...

    def test_technique(self, technique: Dict[str, Any]) -> str:
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        # --- НАЧАЛО ИЗМЕНЕНИЯ: Маршрутизация на новый тест ---
        if tech_type == 'ttl_fake_race':
            return self._test_ttl_fake_race(technique['params'])
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---
            
        if tech_type == 'fooling_variation' and technique.get('value') == 'badseq':
            return self._test_badseq_fooling()
        
        if tech_type == 'seqovl_variation':
            return self._test_seqovl_technique(technique['params'])

        # ... (остальная логика без изменений) ...

    # ... (_test_badseq_fooling и _test_seqovl_technique без изменений) ...

    # --- НАЧАЛО ИЗМЕНЕНИЯ: Новый метод для TTL Fake Race ---
    def _test_ttl_fake_race(self, params: Dict[str, Any]) -> str:
        """
        Тестирует отправку фейкового пакета с низким TTL, а затем реального.
        """
        fake_ttl = params.get('fake_ttl', 5)

        # --- Шаг 1: Устанавливаем TCP-соединение ---
        session_sport = RandShort()
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='S', seq=seq_num)
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: Отправляем фейковый пакет с заданным TTL ---
        fake_payload = b"GET / HTTP/1.0\r\n\r\n"
        fake_packet = IP(dst=self.analyzer.target_ip, ttl=fake_ttl) / TCP(
            sport=session_sport, dport=self.analyzer.target_port, flags='PA',
            seq=syn_ack.ack, # seq может быть любым, но для порядка используем правильный
            ack=syn_ack.seq + 1
        ) / Raw(load=fake_payload)
        
        send(fake_packet, verbose=0)
        self.logger.debug(f"Sent fake packet with TTL={fake_ttl}")
        time.sleep(0.05)

        # --- Шаг 3: Отправляем реальный пакет с нормальным TTL ---
        real_payload = config.build_client_hello(self.target_domain)
        real_packet = IP(dst=self.analyzer.target_ip) / TCP(
            sport=session_sport, dport=self.analyzer.target_port, flags='PA',
            seq=syn_ack.ack, # Важно, чтобы seq был правильным
            ack=syn_ack.seq + 1
        ) / Raw(load=real_payload)

        self.logger.debug("Sending real ClientHello packet after TTL-limited fake.")
        response = sr1(real_packet, timeout=config.SOCKET_TIMEOUT, verbose=0)

        return self.analyzer.analyze_response(response)
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END

Шаг 1.3: Улучшите recon/strategy_builder.py

Generated python
# recon/strategy_builder.py

# ... (импорты и __init__) ...

    def build(self, successful_techniques: List[Dict[str, Any]]) -> str:
        # ... (сортировка техник) ...

        final_params = {}
        base_type_parts = set()

        for tech in sorted_techniques:
            tech_category = tech['type'].split('_')[0]

            # --- НАЧАЛО ИЗМЕНЕНИЯ: Добавляем обработку ttl_fake_race ---
            if tech_category == 'ttl_fake_race':
                # Эта техника подразумевает базовый тип 'fake'
                base_type_parts.add('fake')
                # И устанавливает параметр 'ttl' для фейкового пакета
                if 'ttl' not in final_params:
                    final_params['ttl'] = tech['params']['fake_ttl']
            # --- КОНЕЦ ИЗМЕНЕНИЯ ---
            elif tech_category == 'split':
                # ... (остальная логика) ...
            # ...

        if not base_type_parts:
            base_type_parts.add('fake')

        final_base_type = ",".join(sorted(list(base_type_parts)))
        strategy_parts = [f"--dpi-desync={final_base_type}"]
        for key, value in final_params.items():
            strategy_parts.append(f"--dpi-desync-{key}={value}")
            
        return " ".join(strategy_parts)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Что делать дальше?

Примените все три изменения.

Запустите разведку снова: python -m recon.recon rutracker.org -v

Анализируйте вывод:

Теперь первым делом будет тестироваться категория TTL_FAKE_RACE.

Внимательно смотрите на результат для fake_ttl: 5. Есть очень высокая вероятность, что этот тест вернет SUCCESS.

Если это произойдет, ReconStrategyBuilder сгенерирует вам готовую рабочую стратегию, например: --dpi-desync=fake --dpi-desync-ttl=5.

Это самый многообещающий тест на данный момент, так как он основан на конкретных данных, полученных на предыдущих шагах разведки.
Конечно. Вот полный код метода build из файла recon/strategy_builder.py с учетом всех наших предыдущих обсуждений и новой логики для обработки ttl_fake_race.

Этот метод теперь умеет:

Сортировать найденные успешные техники по заданному приоритету.

Интеллектуально комбинировать их в одну финальную стратегию.

Правильно обрабатывать новую технику ttl_fake_race.

Комбинировать несколько fooling-методов, если они сработали.

Выбирать наиболее подходящий base_type на основе сработавших техник.

Файл: recon/strategy_builder.py
Generated python
# recon/strategy_builder.py

import logging
from typing import List, Dict, Any
from . import config

class ReconStrategyBuilder:
    """Собирает финальную стратегию из успешных техник."""

    def __init__(self, logger: logging.Logger):
        self.logger = logger

    def build(self, successful_techniques: List[Dict[str, Any]]) -> str:
        """
        Собирает итоговую строку стратегии на основе успешных техник.
        Версия 2.0: Умная комбинация техник.
        """
        if not successful_techniques:
            return "--dpi-desync=fake # Fallback: no successful techniques found"

        # Сортируем техники по приоритету, чтобы правильно их комбинировать
        sorted_techniques = sorted(
            successful_techniques,
            key=lambda t: config.TECHNIQUE_PRIORITY.index(t['type'].split('_')[0]) if t['type'].split('_')[0] in config.TECHNIQUE_PRIORITY else 99
        )
        
        self.logger.info(f"Building strategy from successful techniques: {sorted_techniques}")

        final_params: Dict[str, Any] = {}
        base_type_parts: set[str] = set()

        for tech in sorted_techniques:
            # Определяем категорию техники (ttl, split, fooling и т.д.)
            tech_category = tech['type'].split('_')[0]

            if tech_category == 'ttl_fake_race':
                # Эта техника подразумевает базовый тип 'fake'
                base_type_parts.add('fake')
                # Устанавливаем параметр 'ttl' для фейкового пакета
                if 'ttl' not in final_params:
                    final_params['ttl'] = tech['params']['fake_ttl']

            elif tech_category == 'seqovl':
                # Если есть seqovl, то базовый тип должен быть disorder
                if 'multisplit' in base_type_parts:
                    base_type_parts.remove('multisplit')
                base_type_parts.add('multidisorder')
                final_params.update(tech.get('params', {}))

            elif tech_category == 'split':
                # Простой сплит
                base_type_parts.add('multisplit')
                final_params.update(tech.get('params', {}))

            elif tech_category == 'fooling':
                # Можно комбинировать несколько fooling-методов
                current_fooling = final_params.get('fooling', [])
                if not isinstance(current_fooling, list):
                    current_fooling = [current_fooling]
                
                new_fooling = tech.get('value')
                if new_fooling and new_fooling not in current_fooling:
                    current_fooling.append(new_fooling)
                
                if current_fooling:
                    final_params['fooling'] = ",".join(current_fooling)

            elif tech_category == 'ttl':
                # Простая вариация TTL (менее приоритетная, чем ttl_fake_race)
                if 'ttl' not in final_params:
                    final_params['ttl'] = tech.get('value')

        # Если не было найдено техник, меняющих base_type, ставим 'fake' по умолчанию
        if not base_type_parts:
            base_type_parts.add('fake')

        # Собираем финальную строку
        # Если есть и 'fake', и что-то еще, 'fake' часто идет в комбинации
        if 'fake' in base_type_parts and len(base_type_parts) > 1:
            # Например, 'fake,multidisorder'
            pass # Оставляем как есть
        # Если только 'multisplit' и 'multidisorder', это невозможно, disorder имеет приоритет
        elif 'multisplit' in base_type_parts and 'multidisorder' in base_type_parts:
            base_type_parts.remove('multisplit')

        final_base_type = ",".join(sorted(list(base_type_parts)))
        
        strategy_parts = [f"--dpi-desync={final_base_type}"]
        for key, value in final_params.items():
            # Пропускаем пустые или None значения
            if value is None or value == '':
                continue
            strategy_parts.append(f"--dpi-desync-{key}={value}")
            
        return " ".join(strategy_parts)
Это очень показательный результат. Мы исчерпали все "простые" и "средние" техники, и DPI вашего провайдера оказался к ним устойчив.

Финальный Анализ Результатов Разведки

ttl_fake_race -> RST_RECEIVED: Это самый важный вывод. Даже когда мы пытаемся "отвлечь" DPI, отправив фейковый пакет точно на него (с TTL=5), а затем отправляем настоящий, DPI все равно успевает проанализировать настоящий пакет и сбросить соединение.

Общий вывод: Мы имеем дело с продвинутым, stateful DPI, который:

Не обманывается простыми фейками (badseq).

Не обманывается простой фрагментацией (split).

Не обманывается перекрытием сегментов (seqovl).

Не обманывается "гоночной" атакой с TTL (ttl_fake_race).

Он терпеливо ждет и накапливает пакеты, пока не соберет достаточно данных для анализа (в данном случае, полный ClientHello), и только потом принимает решение о блокировке.

Это означает, что нам нужно использовать самую мощную технику из арсенала zapret, которая специально создана для борьбы с такими системами: fakeddisorder.

Что такое fakeddisorder и почему это должно сработать?

fakeddisorder (fake + disordered) — это комбинированная атака, которая делает сразу несколько вещей, чтобы максимально запутать DPI:

Сегментация: Запрос (наш ClientHello) разрезается на две части.

Изменение порядка (Disorder): Части отправляются в обратном порядке: сначала вторая, потом первая.

Фейки (Fake): Каждая из этих частей "обрамляется" фейковыми пакетами.

Как это выглядит на сетевом уровне:

[Фейк для 2-й части]

[РЕАЛЬНАЯ 2-я ЧАСТЬ]

[Фейк для 2-й части]

[Фейк для 1-й части]

[РЕАЛЬНАЯ 1-я ЧАСТЬ]

[Фейк для 1-й части]

Почему это эффективно:
Stateful DPI пытается собрать из этого потока пакетов осмысленную сессию. Но из-за обратного порядка и обилия фейков он с высокой вероятностью соберет "мусорную" сессию (например, [Фейк 2] + [Фейк 1]) и решит, что это невалидный трафик, который можно пропустить. В то же время, TCP/IP стек на конечном сервере, следуя строгим правилам RFC, правильно отбросит все фейки, дождется обеих реальных частей и соберет из них корректный ClientHello.

План Действий: Реализация fakeddisorder в "Разведчике"

Нам нужно научить TechniqueTester симулировать эту атаку. Это будет самая сложная симуляция из всех, что мы делали.

1. Обновление recon/config.py

Добавим новую, самую приоритетную категорию для тестирования.

Generated python
# recon/config.py

TECHNIQUES_TO_TEST = {
    "baseline": [
        {'type': 'baseline_tcp_handshake'}
    ],
    # --- НАЧАЛО ИЗМЕНЕНИЯ: Новая, самая мощная техника ---
    "fakeddisorder": [
        # Пробуем разные точки сплита
        {'type': 'fakeddisorder_variation', 'params': {'split-pos': '3'}},
        {'type': 'fakeddisorder_variation', 'params': {'split-pos': '10'}},
        {'type': 'fakeddisorder_variation', 'params': {'split-pos': '30'}},
    ],
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---
    "ttl_fake_race": [
        {'type': 'ttl_fake_race', 'params': {'fake_ttl': 5}},
    ],
    "seqovl": [
        {'type': 'seqovl_variation', 'params': {'split-pos': '3', 'split-seqovl': '10'}},
    ],
    "fooling": [
        {'type': 'fooling_variation', 'value': 'badseq'},
    ],
}

TECHNIQUE_PRIORITY = [
    'fakeddisorder', # <-- Самый высокий приоритет
    'ttl_fake_race',
    'seqovl',
    'split',
    'fooling',
    'ttl'
]

2. Реализация _test_fakeddisorder_technique в recon/technique_tester.py

Это потребует отправки 4 пакетов в правильной последовательности.

Generated python
# recon/technique_tester.py

# ... (импорты и начало класса) ...

class TechniqueTester:
    # ... (__init__) ...

    def test_technique(self, technique: Dict[str, Any]) -> str:
        tech_type = technique.get('type')
        self.logger.info(f"Testing technique: {tech_type} with params {technique.get('params', technique.get('value'))}")

        # --- НАЧАЛО ИЗМЕНЕНИЯ: Маршрутизация на fakeddisorder ---
        if tech_type == 'fakeddisorder_variation':
            return self._test_fakeddisorder_technique(technique['params'])
        # --- КОНЕЦ ИЗМЕНЕНИЯ ---

        if tech_type == 'ttl_fake_race':
            return self._test_ttl_fake_race(technique['params'])
        # ... (остальная логика) ...

    # ... (_test_badseq_fooling и _test_seqovl_technique) ...
    # ... (_test_ttl_fake_race) ...

    # --- НАЧАЛО ИЗМЕНЕНИЯ: Новый метод для fakeddisorder ---
    def _test_fakeddisorder_technique(self, params: Dict[str, Any]) -> str:
        """
        Тестирует атаку fakeddisorder.
        """
        split_pos = int(params.get('split-pos', 3))
        
        # --- Шаг 1: Устанавливаем TCP-соединение ---
        session_sport = RandShort()
        seq_num = random.randint(0, 2**32 - 1)
        syn = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='S', seq=seq_num)
        syn_ack = sr1(syn, timeout=config.SOCKET_TIMEOUT, verbose=0)
        
        if syn_ack is None or not syn_ack.haslayer(TCP) or not (syn_ack.getlayer(TCP).flags.S and syn_ack.getlayer(TCP).flags.A):
            return "TIMEOUT_OR_RST_ON_SYN"

        # --- Шаг 2: Подготовка сегментов и фейков ---
        full_payload = config.build_client_hello(self.target_domain)
        if split_pos >= len(full_payload):
            return "INVALID_PARAMS"

        part1_payload = full_payload[:split_pos]
        part2_payload = full_payload[split_pos:]
        
        # Фейки - это просто мусорные данные того же размера, что и реальные части
        fake1_payload = b'F' * len(part1_payload)
        fake2_payload = b'A' * len(part2_payload)

        # --- Шаг 3: Отправка пакетов в порядке fakeddisorder ---
        # Пакеты для второй части
        p2_fake = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='PA', seq=syn_ack.ack, ack=syn_ack.seq + 1) / Raw(load=fake2_payload)
        p2_real = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='PA', seq=syn_ack.ack + len(fake2_payload), ack=syn_ack.seq + 1) / Raw(load=part2_payload)
        
        # Пакеты для первой части
        p1_fake = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='PA', seq=syn_ack.ack + len(fake2_payload) + len(part2_payload), ack=syn_ack.seq + 1) / Raw(load=fake1_payload)
        p1_real = IP(dst=self.analyzer.target_ip) / TCP(sport=session_sport, dport=self.analyzer.target_port, flags='PA', seq=syn_ack.ack + len(fake2_payload) + len(part2_payload) + len(fake1_payload), ack=syn_ack.seq + 1) / Raw(load=part1_payload)

        # Отправляем в обратном порядке, не дожидаясь ответа
        self.logger.debug("Sending Part 2 Fake...")
        send(p2_fake, verbose=0)
        time.sleep(0.05)
        
        self.logger.debug("Sending Part 2 Real...")
        send(p2_real, verbose=0)
        time.sleep(0.05)

        self.logger.debug("Sending Part 1 Fake...")
        send(p1_fake, verbose=0)
        time.sleep(0.05)

        # --- Шаг 4: Отправляем последний пакет и ждем ответа ---
        self.logger.debug("Sending Part 1 Real and waiting for response...")
        response = sr1(p1_real, timeout=config.SOCKET_TIMEOUT, verbose=0)

        return self.analyzer.analyze_response(response)
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
3. Обновление recon/strategy_builder.py
Generated python
# recon/strategy_builder.py

# ...

    def build(self, successful_techniques: List[Dict[str, Any]]) -> str:
        # ... (сортировка) ...

        final_params: Dict[str, Any] = {}
        base_type_parts: set[str] = set()

        for tech in sorted_techniques:
            tech_category = tech['type'].split('_')[0]

            # --- НАЧАЛО ИЗМЕНЕНИЯ: Добавляем обработку fakeddisorder ---
            if tech_category == 'fakeddisorder':
                base_type_parts.add('fakeddisorder')
                final_params.update(tech.get('params', {}))
            # --- КОНЕЦ ИЗМЕНЕНИЯ ---
            elif tech_category == 'ttl_fake_race':
                # ... (остальная логика) ...
        
        # ... (остальная логика) ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Python
IGNORE_WHEN_COPYING_END
Что делать дальше?

Примените все три изменения.

Запустите разведку снова: python -m recon.recon rutracker.org -v

Анализируйте вывод:

Теперь первым тестом будет fakeddisorder_variation.

Это наш главный кандидат на успех. Если этот тест вернет SUCCESS, это будет означать, что мы нашли рабочую стратегию. ReconStrategyBuilder соберет что-то вроде --dpi-desync=fakeddisorder --dpi-desync-split-pos=3.

Если и эта атака не сработает, это будет означать, что DPI либо использует еще более сложные методы анализа, либо блокировка происходит не на уровне TCP/TLS, а, например, по IP (что маловероятно для таких крупных ресурсов, как rutracker).

Это последняя из "классических" техник, которую мы можем симулировать. Если она не сработает, нам придется вернуться к основному проекту и использовать его для тестирования более широкого спектра комбинаций, но уже с пониманием того, что DPI очень устойчив.

C:\Users\admin\Downloads\zapretttt\DPI_Blockcheck\recon>recon.py rutracker.org
2025-07-11 17:17:13,026 - ReconApp - INFO - Starting reconnaissance for rutracker.org:443
2025-07-11 17:17:13,063 - ReconApp - INFO - Resolved rutracker.org to 172.67.182.196
2025-07-11 17:17:13,063 - ReconApp - INFO - --- Testing category: BASELINE ---
2025-07-11 17:17:13,066 - ReconApp - INFO - Testing technique: baseline_tcp_handshake with params None
2025-07-11 17:17:13,197 - ReconApp - INFO - [-] FAIL: Technique {'type': 'baseline_tcp_handshake'} result: RST_RECEIVED
2025-07-11 17:17:13,197 - ReconApp - INFO - --- Testing category: FAKEDDISORDER ---
2025-07-11 17:17:13,199 - ReconApp - INFO - Testing technique: fakeddisorder_variation with params {'split-pos': '3'}
2025-07-11 17:17:13,485 - ReconApp - INFO - [-] FAIL: Technique {'type': 'fakeddisorder_variation', 'params': {'split-pos': '3'}} result: RST_RECEIVED
2025-07-11 17:17:13,486 - ReconApp - INFO - Testing technique: fakeddisorder_variation with params {'split-pos': '10'}
2025-07-11 17:17:13,766 - ReconApp - INFO - [-] FAIL: Technique {'type': 'fakeddisorder_variation', 'params': {'split-pos': '10'}} result: RST_RECEIVED
2025-07-11 17:17:13,766 - ReconApp - INFO - Testing technique: fakeddisorder_variation with params {'split-pos': '30'}
2025-07-11 17:17:14,040 - ReconApp - INFO - [-] FAIL: Technique {'type': 'fakeddisorder_variation', 'params': {'split-pos': '30'}} result: RST_RECEIVED
2025-07-11 17:17:14,040 - ReconApp - INFO - --- Testing category: TTL_FAKE_RACE ---
2025-07-11 17:17:14,042 - ReconApp - INFO - Testing technique: ttl_fake_race with params {'fake_ttl': 5}
2025-07-11 17:17:14,251 - ReconApp - INFO - [-] FAIL: Technique {'type': 'ttl_fake_race', 'params': {'fake_ttl': 5}} result: RST_RECEIVED
2025-07-11 17:17:14,251 - ReconApp - INFO - Testing technique: ttl_fake_race with params {'fake_ttl': 6}
2025-07-11 17:17:14,415 - ReconApp - INFO - [-] FAIL: Technique {'type': 'ttl_fake_race', 'params': {'fake_ttl': 6}} result: RST_RECEIVED
2025-07-11 17:17:14,415 - ReconApp - INFO - Testing technique: ttl_fake_race with params {'fake_ttl': 4}
2025-07-11 17:17:14,600 - ReconApp - INFO - [-] FAIL: Technique {'type': 'ttl_fake_race', 'params': {'fake_ttl': 4}} result: RST_RECEIVED
2025-07-11 17:17:14,601 - ReconApp - INFO - --- Testing category: SEQOVL ---
2025-07-11 17:17:14,603 - ReconApp - INFO - Testing technique: seqovl_variation with params {'split-pos': '3', 'split-seqovl': '10'}
2025-07-11 17:17:14,763 - ReconApp - INFO - [-] FAIL: Technique {'type': 'seqovl_variation', 'params': {'split-pos': '3', 'split-seqovl': '10'}} result: RST_RECEIVED
2025-07-11 17:17:14,764 - ReconApp - INFO - Testing technique: seqovl_variation with params {'split-pos': 'host', 'split-seqovl': '50'}
2025-07-11 17:17:14,765 - ReconApp - WARNING - Marker-based seqovl ('host') is not yet supported in recon. Skipping test.
2025-07-11 17:17:14,765 - ReconApp - INFO - [-] FAIL: Technique {'type': 'seqovl_variation', 'params': {'split-pos': 'host', 'split-seqovl': '50'}} result: NOT_SUPPORTED
2025-07-11 17:17:14,765 - ReconApp - INFO - --- Testing category: FOOLING ---
2025-07-11 17:17:14,765 - ReconApp - INFO - Testing technique: fooling_variation with params badsum
2025-07-11 17:17:14,765 - ReconApp - WARNING - Technique 'fooling_variation' with value 'badsum' is complex and not yet supported.
2025-07-11 17:17:14,765 - ReconApp - INFO - [-] FAIL: Technique {'type': 'fooling_variation', 'value': 'badsum'} result: NOT_SUPPORTED
2025-07-11 17:17:14,765 - ReconApp - INFO - Testing technique: fooling_variation with params md5sig
2025-07-11 17:17:14,765 - ReconApp - WARNING - Technique 'fooling_variation' with value 'md5sig' is complex and not yet supported.
2025-07-11 17:17:14,765 - ReconApp - INFO - [-] FAIL: Technique {'type': 'fooling_variation', 'value': 'md5sig'} result: NOT_SUPPORTED
2025-07-11 17:17:14,765 - ReconApp - INFO - Testing technique: fooling_variation with params badseq
2025-07-11 17:17:14,946 - ReconApp - INFO - [-] FAIL: Technique {'type': 'fooling_variation', 'value': 'badseq'} result: RST_RECEIVED
2025-07-11 17:17:14,947 - ReconApp - INFO - --- Testing category: SPLIT ---
2025-07-11 17:17:14,949 - ReconApp - INFO - Testing technique: split_variation with params {'split-pos': '1'}
2025-07-11 17:17:15,058 - ReconApp - INFO - [-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': '1'}} result: RST_RECEIVED
2025-07-11 17:17:15,058 - ReconApp - INFO - Testing technique: split_variation with params {'split-pos': '2'}
2025-07-11 17:17:15,163 - ReconApp - INFO - [-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': '2'}} result: RST_RECEIVED
2025-07-11 17:17:15,163 - ReconApp - INFO - Testing technique: split_variation with params {'split-pos': '3'}
2025-07-11 17:17:15,280 - ReconApp - INFO - [-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': '3'}} result: RST_RECEIVED
2025-07-11 17:17:15,280 - ReconApp - INFO - Testing technique: split_variation with params {'split-pos': 'host'}
2025-07-11 17:17:15,284 - ReconApp - WARNING - Marker-based split ('host') is not yet supported in recon. Skipping test.
2025-07-11 17:17:15,285 - ReconApp - INFO - [-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': 'host'}} result: NOT_SUPPORTED
2025-07-11 17:17:15,285 - ReconApp - INFO - Testing technique: split_variation with params {'split-pos': 'midsld'}
2025-07-11 17:17:15,285 - ReconApp - WARNING - Marker-based split ('midsld') is not yet supported in recon. Skipping test.
2025-07-11 17:17:15,286 - ReconApp - INFO - [-] FAIL: Technique {'type': 'split_variation', 'params': {'split-pos': 'midsld'}} result: NOT_SUPPORTED
2025-07-11 17:17:15,286 - ReconApp - INFO - --- Testing category: TTL ---
2025-07-11 17:17:15,286 - ReconApp - INFO - Testing technique: ttl_variation with params 5
2025-07-11 17:17:20,358 - ReconApp - INFO - [-] FAIL: Technique {'type': 'ttl_variation', 'value': 5} result: TIMEOUT
2025-07-11 17:17:20,358 - ReconApp - INFO - Testing technique: ttl_variation with params 6
2025-07-11 17:17:20,466 - ReconApp - INFO - [-] FAIL: Technique {'type': 'ttl_variation', 'value': 6} result: NON_TCP_RESPONSE
2025-07-11 17:17:20,466 - ReconApp - INFO - Testing technique: ttl_variation with params 7
2025-07-11 17:17:25,574 - ReconApp - INFO - [-] FAIL: Technique {'type': 'ttl_variation', 'value': 7} result: TIMEOUT
2025-07-11 17:17:25,574 - ReconApp - WARNING - ==================================================
2025-07-11 17:17:25,576 - ReconApp - WARNING - Reconnaissance complete. No simple working techniques found.
2025-07-11 17:17:25,577 - ReconApp - WARNING - The block might be more complex or the host is down.

Это исчерпывающий и очень показательный результат. Мы методично перебрали все основные классы атак, которые можно симулировать с помощью Scapy, и ни одна из них не увенчалась успехом.
Финальный Анализ и Выводы по Модулю recon
DPI чрезвычайно устойчив: Мы можем с высокой долей уверенности заключить, что DPI вашего провайдера — это современная, stateful-система, которая не поддается на "классические" трюки с фрагментацией, изменением порядка пакетов, TTL или простыми фейками. Он корректно выполняет TCP-реассемблинг и ждет полного ClientHello для анализа.
Симуляция достигла своего предела: Возможности нашего "Разведчика" на Scapy исчерпаны. Дальнейшее усложнение симуляций (например, точное воссоздание fakeddisorder с кастомным seqovl-pattern) потребует написания собственного TCP/IP стека, что выходит за рамки разумной сложности для этого модуля.
"Разведчик" выполнил свою задачу: Несмотря на то, что мы не нашли "серебряную пулю", модуль recon полностью выполнил свою задачу. Он:
Подтвердил тип блокировки (SNI).
Определил примерное местоположение DPI (TTL=5).
Доказал, что простые и средние по сложности атаки неэффективны.
Сэкономил нам огромное количество времени, которое мы бы потратили, генерируя и тестируя тысячи заведомо нерабочих стратегий в основном проекте.
Вывод: Пора признать, что найти уязвимость "в лоб" с помощью активной разведки в данном случае не удалось. Это не провал, а важный результат. Он говорит нам, что нужно вернуться к исходному плану: массированному тестированию сложных комбинаций параметров с помощью основного фреймворка и обучению ML-модели для поиска неочевидных зависимостей.
Что Делать Дальше?

эксперт который помогал разрабатывать проект "recon" - сказал что дальше надо возвращаться к проекту с генерацией стратегий и дорабатывать его. но я думаю что ты сможешь вдохнуть жизнь в проект recon и реализовать в нем идеи которые смогут  сделать то для чего проект задумывался, а именно "умно вскрывать" DPI анализируя ответы рукопожатий а не просто перебор как основной проект . из более менее "умного" в проекте recon это то что мы можем понять через сколько хопов находится dpi, однако это тоже не даёт нам преимуществ в итоге.