"""
Registry Integration Module

Handles integration with AttackRegistry for dynamic attack discovery.
"""

import logging
from typing import Dict, Set, Any, Optional


def get_hardcoded_attacks() -> tuple[Set[str], Dict[str, list]]:
    """
    Get hardcoded attack definitions as fallback.

    Returns:
        Tuple of (known_attacks, required_params)
    """
    known_attacks = {
        # Combination attack types
        "combo",
        "adaptive_combo",
        "dpi_response_adaptive",
        "multi_layer_combo",
        "steganography_combo",
        "tcp_http_combo",
        # Core attack types from AttackRegistry
        "fakeddisorder",
        "seqovl",
        "multidisorder",
        "disorder",
        "disorder2",
        "multisplit",
        "split",
        "fake",
        # CRITICAL FIX: Add missing attack types
        "ttl",
        "ttl_manipulation",
        "passthrough",
        "badseq",
        "badsum",
        "md5sig",
        "fragmentation",
        "fooling",
        # Aliases from AttackRegistry
        "fake_disorder",
        "fakedisorder",
        "seq_overlap",
        "overlap",
        "multi_disorder",
        "simple_disorder",
        "disorder_ack",
        "multi_split",
        "simple_split",
        "fake_race",
        "race",
        # Legacy compatibility types
        "fragment-tls",
        "fake-sni-random",
        "tls13-only",
        # Additional common variations
        "fake_packet_race",
        "sequence_overlap",
        "packet_split",
        "packet_disorder",
        "multi_packet_split",
        # Generated strategy variations (auto-generated by optimization system)
        "split_basic_fragmentation_optimized",
        "multisplit_basic_fragmentation_optimized",
        "split_basic_fragmentation",
        "multisplit_basic_fragmentation",
    }

    required_params = {
        # Core attack types with their required parameters (matching AttackRegistry)
        "fakeddisorder": ["split_pos"],
        "seqovl": ["split_pos", "overlap_size"],
        "multidisorder": [],
        "disorder": [],
        "disorder2": [],
        "multisplit": [],
        "split": ["split_pos"],
        "fake": ["ttl"],
        # CRITICAL FIX: Add missing attack parameters
        "ttl": ["ttl"],
        "ttl_manipulation": ["ttl"],
        "passthrough": [],
        "badseq": [],
        "badsum": [],
        "md5sig": [],
        "fragmentation": ["split_pos"],
        "fooling": [],
        # Aliases mapping to same requirements as main types
        "fake_disorder": ["split_pos"],
        "fakedisorder": ["split_pos"],
        "seq_overlap": ["split_pos", "overlap_size"],
        "overlap": ["split_pos", "overlap_size"],
        "multi_disorder": [],
        "simple_disorder": [],
        "disorder_ack": [],
        "multi_split": [],
        "simple_split": ["split_pos"],
        "fake_race": ["ttl"],
        "race": ["ttl"],
        # Legacy compatibility types
        "fragment-tls": [],
        "fake-sni-random": [],
        "tls13-only": [],
        # Additional variations for backward compatibility
        "fake_packet_race": ["ttl"],
        "sequence_overlap": ["split_pos", "overlap_size"],
        "packet_split": ["split_pos"],
        "packet_disorder": [],
        "multi_packet_split": [],
        # Generated strategy variations
        "split_basic_fragmentation_optimized": [],
        "multisplit_basic_fragmentation_optimized": [],
        "split_basic_fragmentation": [],
        "multisplit_basic_fragmentation": [],
        # Combination attack types
        "combo": [],
    }

    return known_attacks, required_params


def enhance_loader_with_registry(
    known_attacks: Set[str],
    required_params: Dict[str, list],
    debug: bool = False,
    logger: Optional[logging.Logger] = None,
) -> tuple[Set[str], Dict[str, list], Any]:
    """
    Enhance known_attacks and required_params with AttackRegistry data.

    Args:
        known_attacks: Initial set of known attacks
        required_params: Initial required parameters dict
        debug: Enable debug logging
        logger: Logger instance

    Returns:
        Tuple of (enhanced_known_attacks, enhanced_required_params, registry_instance)
    """
    if logger is None:
        logger = logging.getLogger(__name__)

    try:
        from core.bypass.attacks.attack_registry import get_attack_registry

        registry = get_attack_registry()

        # Get all registered attacks from the registry
        registered_attacks = registry.list_attacks()

        # Clear existing known_attacks and required_params to avoid conflicts
        # Keep only the basic legacy attacks that might not be in registry
        legacy_attacks = {"fragment-tls", "fake-sni-random", "tls13-only", "combo"}

        # Reset to only legacy attacks
        enhanced_known_attacks = legacy_attacks.copy()
        legacy_required_params = {
            "fragment-tls": [],
            "fake-sni-random": [],
            "tls13-only": [],
            "combo": [],
        }

        # Add all registered attacks from AttackRegistry
        for attack_type in registered_attacks:
            enhanced_known_attacks.add(attack_type)

            metadata = registry.get_attack_metadata(attack_type)
            if metadata:
                required_params[attack_type] = metadata.required_params

                # Also add aliases
                for alias in metadata.aliases:
                    enhanced_known_attacks.add(alias)
                    required_params[alias] = metadata.required_params
            else:
                # Fallback for attacks without metadata
                required_params[attack_type] = []

            # Special handling for combo attacks - they have flexible parameters
            if "combo" in attack_type or attack_type.endswith("_combo"):
                required_params[attack_type] = []

        # Add legacy required params back
        required_params.update(legacy_required_params)

        # Add generated strategy variations (auto-generated by optimization system)
        generated_attacks = {
            "split_basic_fragmentation_optimized",
            "multisplit_basic_fragmentation_optimized",
            "split_basic_fragmentation",
            "multisplit_basic_fragmentation",
        }
        enhanced_known_attacks.update(generated_attacks)

        # Add parameters for generated attacks
        for attack in generated_attacks:
            required_params[attack] = []

        if debug:
            logger.debug(f"Enhanced with {len(registered_attacks)} attacks from AttackRegistry")
            logger.debug(f"Total known attacks: {len(enhanced_known_attacks)}")
            logger.debug(f"Total required params entries: {len(required_params)}")

        return enhanced_known_attacks, required_params, registry

    except (ImportError, AttributeError) as e:
        logger.warning(f"Failed to enhance with AttackRegistry: {e}")
        # Return hardcoded fallback
        fallback_attacks, fallback_params = get_hardcoded_attacks()
        return fallback_attacks, fallback_params, None


def get_registry_instance(cached_registry: Any = None) -> Any:
    """
    Get AttackRegistry instance, using cached version if available.

    Args:
        cached_registry: Previously cached registry instance

    Returns:
        Registry instance or None if unavailable
    """
    if cached_registry is not None:
        return cached_registry

    try:
        from core.bypass.attacks.attack_registry import get_attack_registry

        return get_attack_registry()
    except (ImportError, AttributeError):
        return None
