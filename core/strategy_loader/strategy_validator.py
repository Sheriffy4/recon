"""
Strategy validation module for UnifiedStrategyLoader.

This module contains all validation logic for strategies, including:
- Attack combination validation
- Parameter value validation
- Parameter combination validation
- Attack-type-specific validation
- Domain name validation
"""

import logging
from typing import Any, Dict, List, Optional, Set

_DOMAIN_PATTERN = (
    r"^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*"
    r"[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$"
)

try:
    import re

    _DOMAIN_RE = re.compile(_DOMAIN_PATTERN)
except Exception:
    _DOMAIN_RE = None  # pragma: no cover


def _looks_like_dynamic_recipe(name: str) -> bool:
    """
    Dynamic strategy names generated by discovery/diversifier systems.
    These are not canonical AttackRegistry names and should not trigger warnings.
    """
    n = (name or "").lower()
    if n.startswith("fake_ttl"):
        return True
    if n.startswith("disorder_ttl"):
        return True
    # split2, split2_ttl5, etc.
    if n.startswith("split") and len(n) > 5 and n[5].isdigit():
        return True
    if n.startswith(
        (
            "fake_",
            "disorder_",
            "seqovl_",
            "multisplit_",
            "fragmentation_",
            "fooling_",
            "tls_fragmentation",  # Match both plain and suffixed forms (tls_fragmentation, tls_fragmentation_64, etc.)
            "tcp_frag",  # Match both plain and suffixed forms (tcp_frag, tcp_frag_200, etc.)
            "http_fragmentation",  # Match both plain and suffixed forms (http_fragmentation, http_fragmentation_header, etc.)
            "ttl_manipulation",
            "passthrough_",
        )
    ):
        return True
    if "_spl" in n:
        return True
    return False


# Import exceptions - these are defined in the main module
try:
    from core.bypass.attacks.exceptions import StrategyValidationError
except ImportError:
    # Fallback if exceptions module doesn't exist
    class StrategyValidationError(Exception):
        """Raised when strategy validation fails."""

        pass


def validate_attack_combination(
    attacks: List[str],
    params: Dict[str, Any],
    known_attacks: Set[str],
    logger: logging.Logger,
    debug: bool = False,
) -> None:
    """
    Validate attack combination and required parameters.

    Args:
        attacks: List of attack types in combination
        params: Strategy parameters
        known_attacks: Set of known attack types
        logger: Logger instance
        debug: Enable debug logging

    Raises:
        StrategyValidationError: If validation fails critically
    """
    if not attacks:
        logger.error("Validation failed: Empty attacks list")
        raise StrategyValidationError("Empty attacks list")

    validation_warnings = []
    validation_errors = []

    # Check each attack is known/registered
    unknown_attacks = []
    for attack in attacks:
        # Skip validation for dynamic recipe-like names (they will be resolved later)
        if _looks_like_dynamic_recipe(attack):
            continue
        # Skip validation for combo attack names (e.g., "smart_combo_fake_multisplit_disorder")
        # These are dynamically generated strategy names, not individual attack types
        if "combo" in attack.lower() and "_" in attack:
            continue

        if attack not in known_attacks:
            unknown_attacks.append(attack)

    if unknown_attacks:
        # Log warning about unknown attacks
        warning_msg = (
            f"Unknown attack type(s) in combination: {unknown_attacks}. "
            f"Known attacks include: {sorted(list(known_attacks)[:10])}..."
        )
        validation_warnings.append(warning_msg)
        logger.warning(warning_msg)
        logger.warning(f"⚠️ {warning_msg}")

    # Check combination-specific parameter requirements

    # Validate disorder combinations have disorder_method
    disorder_variants = ["disorder", "disorder2", "multidisorder", "fakeddisorder"]
    has_disorder = any(variant in attacks for variant in disorder_variants)

    if has_disorder:
        if "disorder_method" not in params:
            # Set default disorder_method to 'reverse' ONLY if not already set
            params["disorder_method"] = "reverse"
            warning_msg = (
                f"Disorder attack ({[a for a in attacks if a in disorder_variants]}) "
                "in combination but 'disorder_method' parameter missing. "
                "Defaulting to 'reverse'. Expected values: 'reverse', 'random', 'swap'."
            )
            validation_warnings.append(warning_msg)
            logger.warning(f"⚠️ {warning_msg}")
        else:
            # Validate disorder_method value
            disorder_method = params["disorder_method"]
            valid_methods = ["reverse", "random", "swap"]
            if disorder_method not in valid_methods:
                warning_msg = (
                    f"Invalid disorder_method '{disorder_method}'. "
                    f"Valid values: {valid_methods}"
                )
                validation_warnings.append(warning_msg)
                logger.warning(f"⚠️ {warning_msg}")
            else:
                if debug:
                    logger.debug(f"✅ Disorder attack validated with method: {disorder_method}")

    # Validate multisplit combinations have split_count or positions (but allow defaults)
    if "multisplit" in attacks:
        has_split_count = "split_count" in params and params["split_count"] is not None
        has_positions = "positions" in params and params["positions"] is not None
        has_split_pos = "split_pos" in params and params["split_pos"] is not None

        # Only warn if ALL parameters are missing AND no defaults will be applied
        # The handler can generate defaults, so this is just an informational warning
        if not has_split_count and not has_positions and not has_split_pos:
            if debug:
                logger.debug(
                    "ℹ️ Multisplit attack will use default parameters. "
                    "Consider specifying 'split_count', 'positions', or 'split_pos' for optimal results."
                )
        else:
            # Validate parameter values if provided
            if has_split_count:
                split_count = params["split_count"]
                if not isinstance(split_count, int) or split_count < 2:
                    warning_msg = (
                        f"Invalid split_count value: {split_count}. " "Expected: integer >= 2"
                    )
                    validation_warnings.append(warning_msg)
                    logger.warning(warning_msg)
                elif debug:
                    logger.debug(f"✅ Multisplit validated with split_count: {split_count}")

            if has_positions:
                positions = params["positions"]
                if not isinstance(positions, list) or len(positions) < 2:
                    warning_msg = (
                        f"Invalid positions value: {positions}. "
                        "Expected: list with at least 2 positions"
                    )
                    validation_warnings.append(warning_msg)
                    logger.warning(warning_msg)
                elif debug:
                    logger.debug(f"✅ Multisplit validated with positions: {positions}")
    # Validate fake attack has ttl parameter
    fake_attacks = [a for a in attacks if "fake" in a.lower()]
    if fake_attacks:
        has_ttl = "ttl" in params and params["ttl"] is not None
        has_fake_ttl = "fake_ttl" in params and params["fake_ttl"] is not None
        has_autottl = "autottl" in params and params["autottl"] is not None

        if not has_ttl and not has_fake_ttl and not has_autottl:
            warning_msg = (
                f"Fake attack ({fake_attacks}) "
                "in combination but no TTL parameter found. "
                "Expected: 'ttl' (1-255), 'fake_ttl' (1-255), or 'autottl' (-10 to 10). "
                "Attack handler will use default TTL which may not be optimal."
            )
            validation_warnings.append(warning_msg)
            logger.warning(warning_msg)
        else:
            # Validate TTL values
            if has_ttl:
                ttl = params["ttl"]
                if not isinstance(ttl, int) or not (1 <= ttl <= 255):
                    warning_msg = f"Invalid ttl value: {ttl}. Expected: integer 1-255"
                    validation_warnings.append(warning_msg)
                    logger.warning(warning_msg)
                elif debug:
                    logger.debug(f"✅ Fake attack validated with ttl: {ttl}")

            if has_autottl:
                autottl = params["autottl"]
                if not isinstance(autottl, int) or not (-10 <= autottl <= 10):
                    warning_msg = f"Invalid autottl value: {autottl}. Expected: integer -10 to 10"
                    validation_warnings.append(warning_msg)
                    logger.warning(warning_msg)
                elif debug:
                    logger.debug(f"✅ Fake attack validated with autottl: {autottl}")

    # Validate seqovl attack parameters (but allow defaults)
    seqovl_variants = ["seqovl", "seq_overlap", "overlap"]
    has_seqovl = any(variant in attacks for variant in seqovl_variants)

    if has_seqovl:
        missing_params = []

        if "overlap_size" not in params or params["overlap_size"] is None:
            missing_params.append("overlap_size (int, bytes to overlap)")

        if "split_pos" not in params or params["split_pos"] is None:
            missing_params.append("split_pos (int or 'sni'/'cipher'/'midsld')")
        # Only warn if parameters are missing AND no defaults will be applied
        # The handler can generate defaults, so this is just an informational warning
        if missing_params:
            if debug:
                logger.debug(
                    f"ℹ️ Sequence overlap attack will use default parameters for: {', '.join(missing_params)}. "
                    "Consider specifying these parameters for optimal results."
                )
        else:
            # Validate parameter values if provided
            overlap_size = params["overlap_size"]
            if not isinstance(overlap_size, int) or overlap_size < 1:
                warning_msg = f"Invalid overlap_size value: {overlap_size}. Expected: integer >= 1"
                validation_warnings.append(warning_msg)
                logger.warning(warning_msg)
            elif debug:
                logger.debug(f"✅ Sequence overlap validated with overlap_size: {overlap_size}")

    # Validate split attack has split_pos
    if "split" in attacks:
        if "split_pos" not in params or params["split_pos"] is None:
            warning_msg = (
                "Split attack missing 'split_pos' parameter. "
                "Expected: integer >= 1 or special value ('sni', 'cipher', 'midsld'). "
                "Attack handler will use default."
            )
            validation_warnings.append(warning_msg)
            logger.warning(f"⚠️ {warning_msg}")
        elif debug:
            logger.debug(f"✅ Split attack validated with split_pos: {params['split_pos']}")

    # Log validation summary
    if validation_errors:
        error_summary = "; ".join(validation_errors)
        logger.error(f"Attack combination validation failed: {error_summary}")
        raise StrategyValidationError(f"Attack combination validation failed: {error_summary}")

    if validation_warnings:
        logger.warning(
            f"Attack combination validation completed with {len(validation_warnings)} warning(s)"
        )
        if debug:
            for i, warning in enumerate(validation_warnings, 1):
                logger.debug(f"  Warning {i}: {warning}")
    else:
        if debug:
            logger.debug(
                f"✅ Attack combination validated successfully: {attacks} "
                f"with {len(params)} parameters"
            )


def validate_strategy_with_registry(
    strategy: Any,  # NormalizedStrategy type
    attack_registry: Any,
    logger: logging.Logger,
    debug: bool = False,
) -> bool:
    """
    Validate strategy parameters and configuration using AttackRegistry.

    Args:
        strategy: Strategy to validate
        attack_registry: AttackRegistry instance (or None for legacy validation)
        logger: Logger instance
        debug: Enable debug logging

    Returns:
        True if valid

    Raises:
        StrategyValidationError: If validation fails
    """
    try:
        # PRIORITY 0: Dynamic recipe-like strategy names - do not validate via AttackRegistry here.
        # They are resolved later by AttackDispatcher (or engine-level logic).
        if _looks_like_dynamic_recipe(strategy.type):
            logger.debug(
                f"✅ Dynamic recipe-like strategy detected: {strategy.type} "
                f"(skipping AttackRegistry validation)"
            )
            validate_parameter_values(strategy, logger, debug)
            return True

        # PRIORITY 1: Special handling for combo attacks - check FIRST to avoid registry warnings
        if strategy.type == "combo" or strategy.type.endswith("_combo") or "combo" in strategy.type:
            logger.debug(
                f"✅ Combo attack type detected: {strategy.type}, using flexible validation"
            )
            # Combo attacks are always valid with flexible parameters
            # Just do basic parameter validation
            validate_parameter_values(strategy, logger, debug)
            return True

        # PRIORITY 2: Special handling for comma-separated combo attacks (e.g., "disorder,multisplit")
        # Check this BEFORE trying AttackRegistry to avoid "Unknown attack type" warnings
        if "," in strategy.type:
            logger.debug(
                f"✅ Comma-separated combo attack detected: {strategy.type}, using combo validation"
            )
            # Validate each individual attack in the combo
            individual_attacks = [attack.strip() for attack in strategy.type.split(",")]

            # Validate that each individual attack exists (but don't fail on unknown attacks)
            valid_attacks = 0
            for attack in individual_attacks:
                if attack_registry and attack_registry.get_attack_metadata(attack):
                    valid_attacks += 1
                else:
                    logger.debug(
                        f"Individual attack '{attack}' not found in registry (may be legacy)"
                    )

            logger.debug(
                f"✅ Combo validation: {valid_attacks}/{len(individual_attacks)} attacks found in registry"
            )

            # Just do basic parameter validation for combo attacks
            validate_parameter_values(strategy, logger, debug)
            return True
        # PRIORITY 3: Standard single attack validation using AttackRegistry
        if attack_registry:
            # Validate parameters using the registry (includes special parameter validation)
            validation_result = attack_registry.validate_parameters(strategy.type, strategy.params)

            if not validation_result.is_valid:
                raise StrategyValidationError(
                    f"AttackRegistry validation failed for '{strategy.type}': {validation_result.error_message}"
                )

            # Log warnings from AttackRegistry validation
            if validation_result.has_warnings():
                for warning in validation_result.warnings:
                    logger.warning(f"Strategy '{strategy.type}' validation warning: {warning}")

        # Additional UnifiedStrategyLoader-specific validation
        validate_parameter_values(strategy, logger, debug)

        # Additional validation for strategy configuration
        if not strategy.no_fallbacks or not strategy.forced:
            logger.warning("Strategy is not configured for forced override.")

        # Validate special parameter combinations
        validate_parameter_combinations(strategy, logger, debug)

        return True

    except ImportError:
        # Fall back to legacy validation if AttackRegistry is not available
        logger.warning("AttackRegistry not available, using legacy validation")
        return legacy_validate_strategy(strategy, None, {}, logger, debug)
    except Exception as e:
        # Fall back to legacy validation on any error
        logger.warning(f"AttackRegistry validation failed, using legacy validation: {e}")
        return legacy_validate_strategy(strategy, None, {}, logger, debug)


def legacy_validate_strategy(
    strategy: Any,  # NormalizedStrategy type
    known_attacks: Optional[Set[str]],
    required_params: Dict[str, List[str]],
    logger: logging.Logger,
    debug: bool = False,
) -> bool:
    """
    Legacy strategy validation for backward compatibility.

    Args:
        strategy: Strategy to validate
        known_attacks: Set of known attack types (or None)
        required_params: Dict mapping attack type to required parameters
        logger: Logger instance
        debug: Enable debug logging

    Returns:
        True if valid

    Raises:
        StrategyValidationError: If validation fails
    """
    # PRIORITY 1: Special handling for combo attacks - they are valid but flexible
    if strategy.type == "combo" or strategy.type.endswith("_combo") or "combo" in strategy.type:
        logger.debug(f"✅ Legacy combo attack type detected: {strategy.type}")
        # Combo attacks are always valid with flexible parameters
        return True

    # PRIORITY 2: Special handling for comma-separated combo attacks (e.g., "disorder,multisplit")
    # Check this FIRST to avoid "Unknown attack type" warnings
    if "," in strategy.type:
        logger.debug(f"✅ Legacy comma-separated combo attack detected: {strategy.type}")
        # Validate each individual attack in the combo
        individual_attacks = [attack.strip() for attack in strategy.type.split(",")]

        if known_attacks:
            valid_attacks = 0
            for attack in individual_attacks:
                if attack in known_attacks:
                    valid_attacks += 1
                else:
                    logger.debug(
                        f"Individual attack '{attack}' not in known_attacks (may be legacy)"
                    )

            logger.debug(
                f"✅ Legacy combo validation: {valid_attacks}/{len(individual_attacks)} attacks found in known_attacks"
            )

        # Combo attacks are always valid with flexible parameters
        return True

    # PRIORITY 3: Standard single attack validation
    # Check if attack type is known
    if known_attacks and strategy.type not in known_attacks:
        logger.warning(f"Unknown attack type: {strategy.type}")

    required = required_params.get(strategy.type, [])

    # Handle backward compatibility for multisplit
    if strategy.type == "multisplit" and "positions" in required:
        # If we have split_count, split_pos, or positions, we can generate positions, so positions is not required
        if (
            "split_count" in strategy.params
            or "split_pos" in strategy.params
            or "positions" in strategy.params
        ):
            required = [param for param in required if param != "positions"]

    # Handle backward compatibility for multidisorder
    if strategy.type == "multidisorder" and "positions" in required:
        # If we have split_pos or positions, we can generate positions, so positions is not required
        if "split_pos" in strategy.params or "positions" in strategy.params:
            required = [param for param in required if param != "positions"]

    # Handle disorder attacks - they can work with default split_pos if not provided
    if strategy.type in ["disorder", "disorder2"] and "split_pos" in required:
        # These attacks can work with default split_pos, so it's not strictly required
        # The handler will set a default value if needed
        required = [param for param in required if param != "split_pos"]

    # Check for missing parameters, but ignore None values (they will be handled by normalizer)
    missing = []
    for param in required:
        if param not in strategy.params:
            missing.append(param)
        elif strategy.params[param] is None:
            # None values are acceptable - they will be handled by parameter normalizer or attack handler
            continue
    if missing:
        raise StrategyValidationError(
            f"Strategy '{strategy.type}' missing required parameters: {missing}"
        )

    validate_parameter_values(strategy, logger, debug)

    if not strategy.no_fallbacks or not strategy.forced:
        logger.warning("Strategy is not configured for forced override.")

    return True


def validate_parameter_values(
    strategy: Any,  # NormalizedStrategy type
    logger: logging.Logger,
    debug: bool = False,
) -> None:
    """
    Validate individual parameter values including special parameters.

    Args:
        strategy: Strategy to validate
        logger: Logger instance
        debug: Enable debug logging

    Raises:
        StrategyValidationError: If validation fails
    """
    params = strategy.params

    # Import special parameter constants
    try:
        from core.bypass.attacks.metadata import SpecialParameterValues, FoolingMethods
    except ImportError:
        # Fallback to local constants if metadata module is not available
        class SpecialParameterValues:
            CIPHER = "cipher"
            SNI = "sni"
            MIDSLD = "midsld"
            ALL = ["cipher", "sni", "midsld"]

        class FoolingMethods:
            ALL = [
                "badseq",
                "badsum",
                "md5sig",
                "none",
                "hopbyhop",
                "badack",
                "datanoack",
            ]

    # TTL validation with auto-resolution
    if (
        "ttl" in params
        and params.get("ttl") is not None
        and "autottl" in params
        and params.get("autottl") is not None
    ):
        # Auto-resolve conflict: autottl has priority over ttl
        logger.warning("Both ttl and autottl specified. Using autottl and removing ttl.")
        del params["ttl"]

    if "ttl" in params and params["ttl"] is not None:
        ttl = params["ttl"]
        if not isinstance(ttl, int) or not (1 <= ttl <= 255):
            raise StrategyValidationError(
                f"Invalid TTL value: {ttl}. Must be integer between 1 and 255."
            )

    if "fake_ttl" in params and params["fake_ttl"] is not None:
        fake_ttl = params["fake_ttl"]
        if not isinstance(fake_ttl, int) or not (1 <= fake_ttl <= 255):
            raise StrategyValidationError(
                f"Invalid fake_ttl value: {fake_ttl}. Must be integer between 1 and 255."
            )
    if "autottl" in params and params["autottl"] is not None:
        autottl = params["autottl"]
        if not isinstance(autottl, int) or not (-10 <= autottl <= 10):
            raise StrategyValidationError(
                f"Invalid autottl value: {autottl}. Must be integer between -10 and 10."
            )

    # Special parameter validation for split_pos
    if "split_pos" in params and params["split_pos"] is not None:
        split_pos = params["split_pos"]

        if isinstance(split_pos, list):
            # Validate each position in the list
            for i, pos in enumerate(split_pos):
                validate_single_position(pos, f"split_pos[{i}]", SpecialParameterValues.ALL, logger)
        else:
            # Validate single position
            validate_single_position(split_pos, "split_pos", SpecialParameterValues.ALL, logger)

    # Special parameter validation for positions (multisplit/multidisorder)
    if "positions" in params and params["positions"] is not None:
        positions = params["positions"]

        # Handle backward compatibility: convert string to list
        if isinstance(positions, str):
            # Convert comma-separated string to list of integers
            try:
                positions = [int(pos.strip()) for pos in positions.split(",") if pos.strip()]
                params["positions"] = positions
            except ValueError:
                raise StrategyValidationError(
                    f"Invalid positions string: {params['positions']}. Must be comma-separated integers."
                )

        if not isinstance(positions, list):
            raise StrategyValidationError(
                f"Invalid positions parameter: must be a list, got {type(positions).__name__}"
            )

        if len(positions) == 0:
            raise StrategyValidationError("positions list cannot be empty")

        for i, pos in enumerate(positions):
            validate_single_position(pos, f"positions[{i}]", SpecialParameterValues.ALL, logger)

    # Overlap size validation
    if "overlap_size" in params and params["overlap_size"] is not None:
        overlap_size = params["overlap_size"]
        if not isinstance(overlap_size, int) or overlap_size < 0:
            raise StrategyValidationError(
                f"Invalid overlap_size value: {overlap_size}. Must be non-negative integer."
            )

        # Additional validation: overlap_size should be reasonable
        if overlap_size > 1000:
            raise StrategyValidationError(
                f"overlap_size too large: {overlap_size}. Maximum allowed is 1000."
            )
    # Repeats validation
    if "repeats" in params and params["repeats"] is not None:
        repeats = params["repeats"]
        if not isinstance(repeats, int) or not (1 <= repeats <= 10):
            raise StrategyValidationError(
                f"Invalid repeats value: {repeats}. Must be integer between 1 and 10."
            )

    # Fooling methods validation
    if "fooling" in params and params["fooling"] is not None:
        fooling = params["fooling"]
        if not isinstance(fooling, list):
            raise StrategyValidationError(
                f"Invalid fooling parameter: must be a list, got {type(fooling).__name__}"
            )

        # Validate each fooling method
        for method in fooling:
            if not isinstance(method, str):
                raise StrategyValidationError(
                    f"Invalid fooling method: must be string, got {type(method).__name__}"
                )

            if method not in FoolingMethods.ALL:
                raise StrategyValidationError(
                    f"Invalid fooling method '{method}'. Valid methods: {FoolingMethods.ALL}"
                )

    # Fooling methods validation (alternative parameter name)
    if "fooling_methods" in params and params["fooling_methods"] is not None:
        fooling_methods = params["fooling_methods"]
        if not isinstance(fooling_methods, list):
            raise StrategyValidationError(
                f"Invalid fooling_methods parameter: must be a list, got {type(fooling_methods).__name__}"
            )

        for method in fooling_methods:
            if not isinstance(method, str):
                raise StrategyValidationError(
                    f"Invalid fooling method: must be string, got {type(method).__name__}"
                )

            if method not in FoolingMethods.ALL:
                raise StrategyValidationError(
                    f"Invalid fooling method '{method}'. Valid methods: {FoolingMethods.ALL}"
                )

    # Domain validation
    if "domain" in params and params["domain"] is not None:
        domain = params["domain"]
        if not isinstance(domain, str):
            raise StrategyValidationError(
                f"Invalid domain parameter: must be string, got {type(domain).__name__}"
            )

        if not is_valid_domain_name(domain):
            raise StrategyValidationError(f"Invalid domain name: {domain}")


def validate_single_position(
    position: Any, param_name: str, special_values: List[str], logger: logging.Logger
) -> None:
    """
    Validate a single position value (can be int or special string).

    Args:
        position: Position value to validate
        param_name: Name of the parameter (for error messages)
        special_values: List of allowed special string values
        logger: Logger instance

    Raises:
        StrategyValidationError: If validation fails
    """
    if isinstance(position, str):
        # Check if it's a special value
        if position not in special_values:
            raise StrategyValidationError(
                f"Invalid {param_name}: {position}. Must be integer >= 1 or one of special values: {special_values}"
            )
    elif isinstance(position, int):
        # Validate integer position
        if position < 1:
            raise StrategyValidationError(
                f"Invalid {param_name}: {position}. Position must be >= 1"
            )

        # Additional validation: position should be reasonable
        try:
            int_pos = int(position)
            if int_pos > 65535:
                raise StrategyValidationError(
                    f"Invalid {param_name}: {position}. Position too large (max 65535)."
                )
        except ValueError:
            raise StrategyValidationError(
                f"Invalid {param_name}: {position}. Must be integer >= 1 or one of special values: {special_values}"
            )
    else:
        raise StrategyValidationError(
            f"Invalid {param_name}: {position}. Must be integer or string, got {type(position).__name__}"
        )


def is_valid_domain_name(domain: str) -> bool:
    """
    Basic domain name validation.

    Args:
        domain: Domain name to validate

    Returns:
        True if valid, False otherwise
    """
    if not domain or len(domain) > 253:
        return False

    # Basic regex for domain validation
    import re

    domain_pattern = re.compile(
        r"^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$"
    )

    return bool(domain_pattern.match(domain))


def validate_parameter_combinations(
    strategy: Any,  # NormalizedStrategy type
    logger: logging.Logger,
    debug: bool = False,
) -> None:
    """
    Validate special parameter combinations and dependencies.

    Args:
        strategy: Strategy to validate
        logger: Logger instance
        debug: Enable debug logging

    Raises:
        StrategyValidationError: If validation fails
    """
    params = strategy.params
    attack_type = strategy.type

    # Validate seqovl specific requirements
    if attack_type in ["seqovl", "seq_overlap", "overlap"]:
        if "overlap_size" not in params:
            raise StrategyValidationError(
                f"Attack type '{attack_type}' requires 'overlap_size' parameter"
            )

        if "split_pos" not in params:
            raise StrategyValidationError(
                f"Attack type '{attack_type}' requires 'split_pos' parameter"
            )

        # Validate that overlap_size makes sense with split_pos
        overlap_size = params.get("overlap_size", 0)
        split_pos = params.get("split_pos")

        if isinstance(split_pos, int) and isinstance(overlap_size, int):
            if overlap_size >= split_pos:
                raise StrategyValidationError(
                    f"overlap_size ({overlap_size}) must be less than split_pos ({split_pos})"
                )

    # Validate multisplit/multidisorder requirements
    if attack_type in [
        "multisplit",
        "multidisorder",
        "multi_split",
        "multi_disorder",
    ]:
        # Either positions or split_pos should be provided
        if "positions" not in params and "split_pos" not in params:
            raise StrategyValidationError(
                f"Attack type '{attack_type}' requires either 'positions' or 'split_pos' parameter"
            )

        # If both are provided, warn about potential conflict
        if "positions" in params and "split_pos" in params:
            logger.warning(
                f"Both 'positions' and 'split_pos' provided for '{attack_type}'. 'positions' will take precedence."
            )

    # Validate TTL parameter combinations
    if "ttl" in params and "autottl" in params:
        if params["ttl"] is not None and params["autottl"] is not None:
            raise StrategyValidationError("Cannot specify both 'ttl' and 'autottl' parameters")
    # Validate fake packet parameters
    fake_params = ["fake_tls", "fake_http", "fake_syndata", "fake_sni", "fake_data"]
    has_fake_params = any(param in params and params[param] is not None for param in fake_params)

    if has_fake_params and attack_type not in [
        "fakeddisorder",
        "fake_disorder",
        "fakedisorder",
        "fake",
        "fake_race",
        "race",
    ]:
        logger.warning(
            f"Fake packet parameters provided for non-fake attack type '{attack_type}'. They may be ignored."
        )

    # Validate fooling methods consistency
    if "fooling" in params and "fooling_methods" in params:
        if params["fooling"] is not None and params["fooling_methods"] is not None:
            logger.warning(
                "Both 'fooling' and 'fooling_methods' provided. 'fooling' will take precedence."
            )

    # Validate special position values context
    special_positions = []

    # Check split_pos for special values
    if "split_pos" in params:
        split_pos = params["split_pos"]
        if isinstance(split_pos, str) and split_pos in ["cipher", "sni", "midsld"]:
            special_positions.append(split_pos)
        elif isinstance(split_pos, list):
            for pos in split_pos:
                if isinstance(pos, str) and pos in ["cipher", "sni", "midsld"]:
                    special_positions.append(pos)

    # Check positions for special values
    if "positions" in params:
        positions = params["positions"]
        if isinstance(positions, list):
            for pos in positions:
                if isinstance(pos, str) and pos in ["cipher", "sni", "midsld"]:
                    special_positions.append(pos)

    # Warn about TLS-specific special values for non-TLS contexts
    tls_specific = ["cipher", "sni"]
    for special_pos in special_positions:
        if special_pos in tls_specific:
            logger.warning(
                f"Special position '{special_pos}' is TLS-specific. Ensure this strategy is used with TLS traffic."
            )

    # Validate domain-specific special values
    if "midsld" in special_positions:
        logger.warning(
            "Special position 'midsld' requires domain name extraction. Ensure this strategy is used with HTTP/HTTPS traffic."
        )

    # Validate attack type specific parameter requirements
    validate_attack_type_specific_requirements(attack_type, params, logger)


def validate_attack_type_specific_requirements(
    attack_type: str, params: Dict[str, Any], logger: logging.Logger
) -> None:
    """
    Validate attack type specific parameter requirements.

    Args:
        attack_type: Type of attack
        params: Strategy parameters
        logger: Logger instance

    Raises:
        StrategyValidationError: If validation fails
    """
    # Normalize attack type for checking
    normalized_type = attack_type.lower()

    # Split-based attacks require position parameters
    split_attacks = ["split", "simple_split", "multisplit", "multi_split"]
    if normalized_type in split_attacks:
        if "split_pos" not in params and "positions" not in params:
            raise StrategyValidationError(
                f"Split attack '{attack_type}' requires position parameters ('split_pos' or 'positions')"
            )

    # Disorder attacks require position parameters
    disorder_attacks = [
        "disorder",
        "disorder2",
        "simple_disorder",
        "disorder_ack",
        "multidisorder",
        "multi_disorder",
    ]
    if normalized_type in disorder_attacks:
        if "split_pos" not in params and "positions" not in params:
            raise StrategyValidationError(
                f"Disorder attack '{attack_type}' requires position parameters ('split_pos' or 'positions')"
            )

    # Fake attacks require TTL or fake-related parameters
    fake_attacks = [
        "fake",
        "fake_race",
        "race",
        "fakeddisorder",
        "fake_disorder",
        "fakedisorder",
    ]
    if normalized_type in fake_attacks:
        has_ttl = "ttl" in params or "fake_ttl" in params
        has_fake_params = any(
            param in params
            for param in [
                "fake_tls",
                "fake_http",
                "fake_syndata",
                "fake_sni",
                "fake_data",
            ]
        )

        if not has_ttl and not has_fake_params:
            # For fake attacks, we need at least TTL
            if normalized_type in ["fake", "fake_race", "race"]:
                raise StrategyValidationError(
                    f"Fake attack '{attack_type}' requires 'ttl' parameter"
                )
            else:
                # For fakeddisorder, TTL is optional but recommended
                logger.warning(
                    f"Fake attack '{attack_type}' should have 'ttl' or fake packet parameters for optimal effectiveness"
                )

    # Overlap attacks require specific parameters
    overlap_attacks = ["seqovl", "seq_overlap", "overlap"]
    if normalized_type in overlap_attacks:
        required_params = ["split_pos", "overlap_size"]
        missing_params = [param for param in required_params if param not in params]
        if missing_params:
            raise StrategyValidationError(
                f"Overlap attack '{attack_type}' missing required parameters: {missing_params}"
            )
