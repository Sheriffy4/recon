"""
Recipe Resolver for Attack Dispatcher.

Handles resolution of recipe names (like "tls_fragmentation_4") to component attacks
and mapping of recipe parameters to attack parameters.

This module extracts recipe resolution logic from AttackDispatcher to improve
maintainability and testability.
"""

import logging
import re
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


# ============================================================================
# Dynamic recipe patterns (StrategyDiversifier / generators)
# ============================================================================

# IMPORTANT:
# - Use fullmatch to avoid partial matches
# - Allow optional extra suffixes after the key token (StrategyDiversifier appends extra tags)

_RX_FOOLING = re.compile(r"^fooling_.+_foo(?P<method>[A-Za-z]\w*)(?:_.+)?$")

_RX_TLS_FRAG = re.compile(r"^tls_fragmentation_(?P<n>\d+)$")
_RX_TCP_FRAG = re.compile(r"^tcp_frag_(?P<n>\d+)$")
_RX_HTTP_FRAG = re.compile(r"^http_fragmentation_(?P<method>\w+)$")

_RX_FRAGMENTATION_2SPL = re.compile(r"^fragmentation_.+_spl(?P<p1>\d+)_spl(?P<p2>\d+)(?:_.+)?$")

_RX_FAKE_SPL_NUM = re.compile(r"^fake_.+_spl(?P<pos>\d+)(?:_.+)?$")
# NOTE: only letters for special positions, so "splsni_cnt8" won't become split_pos="sni_cnt8"
_RX_FAKE_SPL_STR = re.compile(r"^fake_.+_spl(?P<pos>[A-Za-z]+)(?:_.+)?$")

# Discovery/describer style names:
# Example: fake_ttl3  -> fake with ttl=3
_RX_FAKE_TTL = re.compile(r"^fake_ttl(?P<ttl>\d+)(?:_.+)?$")

# Similar describer names:
# - disorder_ttl4 -> disorder (ttl is informational; may be ignored by some handlers)
_RX_DISORDER_TTL = re.compile(r"^disorder_ttl(?P<ttl>\d+)(?:_.+)?$")
# - split2 -> split_pos=2
_RX_SPLIT_POS = re.compile(r"^split(?P<pos>\d+)(?:_.+)?$")
# - split2_ttl5 -> split_pos=2, ttl=5
_RX_SPLIT_POS_TTL = re.compile(r"^split(?P<pos>\d+)_ttl(?P<ttl>\d+)(?:_.+)?$")

_RX_DISORDER_SPL_DIS = re.compile(r"^disorder_.+_spl(?P<pos>\d+)_dis(?P<n>\d+)(?:_.+)?$")

_RX_SEQOVL_SPL = re.compile(r"^seqovl_.+_spl(?P<pos>\d+)(?:_.+)?$")
_RX_SEQOVL_SPL_STR = re.compile(r"^seqovl_.+_spl(?P<pos>[A-Za-z]+)(?:_.+)?$")

_RX_MULTISPLIT = re.compile(r"^multisplit_.+(?:_.+)?$")

# Passthrough recipes (generated / domain-tagged)
# Example: passthrough_www_googlevideo_com
_RX_PASSTHROUGH = re.compile(r"^passthrough_.+(?:_.+)?$")

# TTL manipulation recipes (generated)
# Examples:
# - ttl_manipulation
# - ttl_manipulation_www_googlevideo_com_ttl1
_RX_TTL_MANIP = re.compile(r"^ttl_manipulation(?:_.+)?_ttl(?P<ttl>\d+)(?:_.+)?$")


class RecipeResolver:
    """
    Resolves recipe names to component attacks and maps parameters.

    Recipes are generated strategy names like:
    - "tls_fragmentation_4" → ["multisplit"] with split_count=4
    - "fake_www_youtube_com_spl3" → ["fake"] with split_pos=3
    - "disorder_domain_spl5_dis2" → ["multidisorder"] with split_pos=5, disorder_count=2

    This class handles:
    1. Pattern matching against known recipe formats
    2. Extraction of parameters from recipe names
    3. Mapping to appropriate attack types
    """

    def __init__(self, registry: Optional[Any] = None):
        """
        Initialize RecipeResolver.

        Args:
            registry: Optional attack registry for checking attack existence
        """
        self.registry = registry

    def resolve_name(self, recipe_name: str) -> Optional[List[str]]:
        """
        Resolve a recipe name to its component attacks.

        This method handles generated strategy names like 'tls_fragmentation_1'
        and maps them to their actual attack components.

        Args:
            recipe_name: The recipe name to resolve

        Returns:
            List of component attack names, or None if not a known recipe
        """
        # Guard: if it is already a registered canonical name, do not treat as recipe.
        if self.registry:
            try:
                canonical = self.registry.get_canonical_name(recipe_name.strip().lower())
                if canonical in getattr(self.registry, "attacks", {}):
                    return None
            except Exception:
                pass

        recipe_name = recipe_name.strip().lower()

        # Recipe mapping for generated strategy names
        recipe_mappings = {
            # TLS fragmentation recipes (generated by StrategyGenerator)
            "tls_fragmentation_1": ["multisplit"],
            "tls_fragmentation_2": ["multisplit"],
            "tls_fragmentation_4": ["multisplit"],
            "tls_fragmentation_8": ["multisplit"],
            # TCP fragmentation recipes
            "tcp_frag_1": ["split"],
            "tcp_frag_2": ["split"],
            "tcp_frag_4": ["split"],
            "tcp_frag_8": ["split"],
            # also support the current StrategyGenerator sizes explicitly
            "tcp_frag_40": ["split"],
            "tcp_frag_80": ["split"],
            "tcp_frag_120": ["split"],
            "tcp_frag_200": ["split"],
            # HTTP fragmentation recipes
            "http_fragmentation": ["disorder"],  # Default to disorder
            "http_fragmentation_header": ["disorder"],
            "http_fragmentation_body": ["disorder"],
            "http_fragmentation_both": ["disorder"],
            # Domain-specific fragmentation recipes (examples)
            "fragmentation_www_youtube_com_spl76_spl4": ["multisplit"],
        }

        # Check exact match first
        if recipe_name in recipe_mappings:
            return recipe_mappings[recipe_name]

        # Pattern-based matching (STRICT)

        if _RX_FOOLING.fullmatch(recipe_name):
            return ["fake"]

        if _RX_FAKE_TTL.fullmatch(recipe_name):
            return ["fake"]

        if _RX_DISORDER_TTL.fullmatch(recipe_name):
            return ["disorder"]

        if _RX_SPLIT_POS_TTL.fullmatch(recipe_name):
            return ["split"]

        if _RX_SPLIT_POS.fullmatch(recipe_name):
            return ["split"]

        if _RX_TLS_FRAG.fullmatch(recipe_name):
            return ["multisplit"]

        # Support plain and domain-suffixed tls_fragmentation names:
        # - tls_fragmentation
        # - tls_fragmentation_<domain>_...
        # If registry already has a real handler/alias, the guard at the top returns None.
        if recipe_name == "tls_fragmentation" or recipe_name.startswith("tls_fragmentation_"):
            return ["multisplit"]

        if _RX_TCP_FRAG.fullmatch(recipe_name):
            return ["split"]

        if _RX_HTTP_FRAG.fullmatch(recipe_name):
            return ["disorder"]

        if _RX_FRAGMENTATION_2SPL.fullmatch(recipe_name) or recipe_name.startswith(
            "fragmentation_"
        ):
            return ["multisplit"]

        if _RX_FAKE_SPL_NUM.fullmatch(recipe_name) or _RX_FAKE_SPL_STR.fullmatch(recipe_name):
            return ["fake"]

        if _RX_DISORDER_SPL_DIS.fullmatch(recipe_name):
            return ["multidisorder"]

        # Narrow disorder fallback: only for generated names containing split marker.
        if recipe_name.startswith("disorder_") and "_spl" in recipe_name:
            return ["disorder"]

        if _RX_SEQOVL_SPL.fullmatch(recipe_name):
            return ["seqovl"]

        if _RX_SEQOVL_SPL_STR.fullmatch(recipe_name):
            return ["seqovl"]

        if _RX_MULTISPLIT.fullmatch(recipe_name):
            return ["multisplit"]

        # passthrough_<domain> -> passthrough
        if _RX_PASSTHROUGH.fullmatch(recipe_name):
            return ["passthrough"]

        # TTL manipulation recipes
        if recipe_name == "ttl_manipulation" or _RX_TTL_MANIP.fullmatch(recipe_name):
            # Prefer dedicated ttl attack if available, otherwise fallback to fake.
            if self.registry:
                try:
                    if self.registry.get_attack_handler("ttl"):
                        return ["ttl"]
                except Exception:
                    pass
            return ["fake"]

        # No recipe found
        return None

    def map_parameters(
        self, recipe_name: str, params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Map recipe parameters to component attack parameters.

        Args:
            recipe_name: The recipe name
            params: Original parameters (optional)

        Returns:
            Mapped parameters for component attacks
        """
        source_params: Dict[str, Any] = params or {}
        mapped_params = source_params.copy()
        recipe_name = (recipe_name or "").strip().lower()

        # For fooling_<domain>_foo<method>, extract the fooling method
        # Example: fooling_www_youtube_com_foobadseq -> fooling=badseq
        match = _RX_FOOLING.fullmatch(recipe_name)
        if match:
            fooling_method = match.group("method")
            mapped_params.update(
                {
                    # normalize to list[str]
                    "fooling": [fooling_method],
                    "fooling_methods": [fooling_method],
                }
            )
            logger.debug(f"Mapped fooling parameters: fooling={fooling_method}")

        # For tls_fragmentation_<number>, extract the number as split_count
        match = _RX_TLS_FRAG.fullmatch(recipe_name)
        if match:
            split_count = int(match.group("n"))
            mapped_params.update(
                {
                    "split_count": split_count,
                    # Add default split_pos if not present
                    "split_pos": mapped_params.get("split_pos", 3),
                }
            )
            logger.debug(f"Mapped tls_fragmentation parameters: split_count={split_count}")

        # For plain tls_fragmentation (or domain-suffixed forms without explicit count),
        # provide a safe default split_count if caller didn't pass one.
        if recipe_name == "tls_fragmentation" or (
            recipe_name.startswith("tls_fragmentation_") and not _RX_TLS_FRAG.fullmatch(recipe_name)
        ):
            mapped_params.setdefault("split_count", 4)
            mapped_params.setdefault("split_pos", 3)

        # For tcp_frag_<number>, extract the number as split_pos
        match = _RX_TCP_FRAG.fullmatch(recipe_name)
        if match:
            fragment_size = int(match.group("n"))
            mapped_params.update({"split_pos": fragment_size, "fragment_size": fragment_size})
            logger.debug(f"Mapped tcp_frag parameters: split_pos={fragment_size}")

        # For http_fragmentation_<method>, extract the method and map to proper disorder_method
        # CRITICAL: fragmentation_method (header/body/both) is different from disorder_method (reverse/random/swap)
        # We preserve fragmentation_method for metadata and map it to appropriate disorder_method
        if recipe_name == "http_fragmentation":
            # Plain http_fragmentation: use existing disorder_method or default to reverse
            method = source_params.get(
                "fragmentation_method", source_params.get("disorder_method", "header")
            )
            # Map fragmentation target to disorder method
            disorder_mapping = {
                "header": "reverse",  # Header fragmentation uses reverse order
                "body": "random",  # Body fragmentation uses random order
                "both": "swap",  # Both uses swap order
                # Also support direct disorder methods
                "reverse": "reverse",
                "random": "random",
                "swap": "swap",
            }
            disorder_method = disorder_mapping.get(method, "reverse")
            mapped_params.update(
                {"fragmentation_method": method, "disorder_method": disorder_method}
            )
            logger.debug(
                f"Mapped http_fragmentation (plain) parameters: fragmentation_method={method}, disorder_method={disorder_method}"
            )
        else:
            match = _RX_HTTP_FRAG.fullmatch(recipe_name)
            if match:
                method = match.group("method")
                # Map fragmentation target to disorder method
                disorder_mapping = {"header": "reverse", "body": "random", "both": "swap"}
                disorder_method = disorder_mapping.get(method, "reverse")
                mapped_params.update(
                    {"fragmentation_method": method, "disorder_method": disorder_method}
                )
                logger.debug(
                    f"Mapped http_fragmentation parameters: fragmentation_method={method}, disorder_method={disorder_method}"
                )

        # For fragmentation_<domain>_spl<number>_spl<number>, extract split parameters
        # Example: fragmentation_www_youtube_com_spl76_spl4
        match = _RX_FRAGMENTATION_2SPL.fullmatch(recipe_name)
        if match:
            split_pos1 = int(match.group("p1"))
            split_pos2 = int(match.group("p2"))

            # Ensure split positions are reasonable (clamp to reasonable values)
            max_reasonable_pos = 200  # Conservative estimate
            split_pos1 = min(split_pos1, max_reasonable_pos)
            split_pos2 = min(split_pos2, max_reasonable_pos)

            # Ensure positions are in ascending order and not too close
            if split_pos1 > split_pos2:
                split_pos1, split_pos2 = split_pos2, split_pos1
            if split_pos2 - split_pos1 < 3:  # Minimum gap of 3 bytes
                split_pos2 = split_pos1 + 3

            mapped_params.update(
                {
                    "positions": [split_pos1, split_pos2],
                    "split_count": 2,
                    "split_pos": split_pos1,  # Use first position as primary
                }
            )
            logger.debug(
                f"Mapped domain fragmentation parameters: positions=[{split_pos1}, {split_pos2}] (clamped from original)"
            )

        # For general fragmentation_<domain> patterns, use default multisplit
        elif recipe_name.startswith("fragmentation_"):
            mapped_params.update({"split_count": 3, "split_pos": mapped_params.get("split_pos", 3)})
            logger.debug("Mapped general fragmentation parameters: split_count=3")

        # For fake_<domain>_spl<number>, extract split position
        match = _RX_FAKE_SPL_NUM.fullmatch(recipe_name)
        if match:
            split_pos = int(match.group("pos"))
            mapped_params.update(
                {
                    "split_pos": split_pos,
                    "fake_ttl": mapped_params.get("fake_ttl", 3),
                    "ttl": mapped_params.get("ttl", 3),
                }
            )
            logger.debug(f"Mapped fake parameters: split_pos={split_pos}")

        # For fake_<domain>_spl<string>, extract split position as string
        match = _RX_FAKE_SPL_STR.fullmatch(recipe_name)
        if match:
            split_pos = match.group("pos")
            mapped_params.update(
                {
                    "split_pos": split_pos,
                    "fake_ttl": mapped_params.get("fake_ttl", 3),
                    "ttl": mapped_params.get("ttl", 3),
                }
            )
            logger.debug(f"Mapped fake parameters: split_pos={split_pos}")

        # fake_ttl<ttl> -> fake with ttl/fake_ttl set
        match = _RX_FAKE_TTL.fullmatch(recipe_name)
        if match:
            ttl_v = int(match.group("ttl"))
            mapped_params.update(
                {
                    "ttl": ttl_v,
                    "fake_ttl": ttl_v,
                }
            )
            logger.debug(f"Mapped fake_ttl recipe parameters: ttl={ttl_v}")

        # disorder_ttl<ttl> -> disorder (+ keep ttl/fake_ttl as informational params)
        match = _RX_DISORDER_TTL.fullmatch(recipe_name)
        if match:
            ttl_v = int(match.group("ttl"))
            mapped_params.update(
                {
                    "ttl": ttl_v,
                    "fake_ttl": ttl_v,
                    "disorder_method": mapped_params.get("disorder_method", "reverse"),
                }
            )
            logger.debug(f"Mapped disorder_ttl recipe parameters: ttl={ttl_v}")

        # split<pos> -> split_pos=pos
        match = _RX_SPLIT_POS.fullmatch(recipe_name)
        if match:
            split_pos = int(match.group("pos"))
            mapped_params.update(
                {
                    "split_pos": split_pos,
                }
            )
            logger.debug(f"Mapped split<pos> recipe parameters: split_pos={split_pos}")

        # split<pos>_ttl<ttl> -> split_pos=pos, ttl/fake_ttl=ttl
        match = _RX_SPLIT_POS_TTL.fullmatch(recipe_name)
        if match:
            split_pos = int(match.group("pos"))
            ttl_v = int(match.group("ttl"))
            mapped_params.update(
                {
                    "split_pos": split_pos,
                    "ttl": ttl_v,
                    "fake_ttl": ttl_v,
                }
            )
            logger.debug(
                f"Mapped split<pos>_ttl<ttl> recipe parameters: split_pos={split_pos}, ttl={ttl_v}"
            )

        # For disorder_<domain>_spl<number>_dis<number>, extract split position and disorder count
        match = _RX_DISORDER_SPL_DIS.fullmatch(recipe_name)
        if match:
            split_pos = int(match.group("pos"))
            disorder_count = int(match.group("n"))
            mapped_params.update(
                {
                    "split_pos": split_pos,
                    "disorder_count": disorder_count,
                    "disorder_method": mapped_params.get("disorder_method", "reverse"),
                }
            )
            logger.debug(
                f"Mapped disorder parameters: split_pos={split_pos}, disorder_count={disorder_count}"
            )

        # For seqovl_<domain>_spl<number>, extract split position
        match = _RX_SEQOVL_SPL.fullmatch(recipe_name)
        if match:
            split_pos = int(match.group("pos"))
            mapped_params.update(
                {
                    "split_pos": split_pos,
                    "overlap_size": mapped_params.get("overlap_size", 3),
                    "fake_ttl": mapped_params.get("fake_ttl", 3),
                }
            )
            logger.debug(f"Mapped seqovl parameters: split_pos={split_pos}")

        match = _RX_SEQOVL_SPL_STR.fullmatch(recipe_name)
        if match:
            split_pos = match.group("pos").lower()
            # allow only known special values
            if split_pos not in ("sni", "cipher", "midsld", "random"):
                logger.debug(f"Unknown seqovl split_pos token '{split_pos}', defaulting to 3")
                split_pos = 3
            mapped_params.update(
                {
                    "split_pos": split_pos,
                    "overlap_size": mapped_params.get("overlap_size", 3),
                    "fake_ttl": mapped_params.get("fake_ttl", 3),
                }
            )
            logger.debug(f"Mapped seqovl parameters: split_pos={split_pos}")

        # For multisplit_<domain>, use default multisplit parameters
        if _RX_MULTISPLIT.fullmatch(recipe_name):
            if "split_count" not in mapped_params and "positions" not in mapped_params:
                mapped_params.update(
                    {"split_count": 8, "split_pos": mapped_params.get("split_pos", 3)}
                )
                logger.debug("Mapped multisplit parameters: split_count=8")

        # TTL manipulation: extract ttl from recipe name if present
        match = _RX_TTL_MANIP.fullmatch(recipe_name)
        if match:
            ttl_v = int(match.group("ttl"))
            # IMPORTANT: ttl encoded in recipe name must override defaults injected earlier
            mapped_params["ttl"] = ttl_v
            mapped_params["fake_ttl"] = ttl_v
            logger.debug(f"Mapped ttl_manipulation parameters: ttl={ttl_v}")

        # Normalize fooling/fooling_methods to list[str]
        if "fooling" in mapped_params and isinstance(mapped_params["fooling"], str):
            mapped_params["fooling"] = [mapped_params["fooling"]]
        if "fooling_methods" in mapped_params and isinstance(mapped_params["fooling_methods"], str):
            mapped_params["fooling_methods"] = [mapped_params["fooling_methods"]]

        return mapped_params
