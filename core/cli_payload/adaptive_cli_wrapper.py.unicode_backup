"""
CLI Wrapper for AdaptiveEngine - Task 2.2 Implementation

Provides enhanced CLI integration for AdaptiveEngine with:
- Rich output formatting
- Comprehensive error handling
- Graceful degradation
- Parameter validation and processing
"""

import asyncio
import json
import logging
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional, List
from dataclasses import dataclass

# Rich imports with fallback
try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
    from rich.table import Table
    from rich.text import Text
    from rich.live import Live
    from rich.layout import Layout
    from rich.align import Align
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False
    # Fallback console
    class Console:
        def print(self, *args, **kwargs):
            print(*args)
    
    class Panel:
        def __init__(self, text, **kwargs):
            self.text = text
        def __str__(self):
            return str(self.text)
    
    class Progress:
        def __init__(self, *args, **kwargs):
            pass
        def __enter__(self):
            return self
        def __exit__(self, *args):
            pass
        def add_task(self, *args, **kwargs):
            return 0
        def update(self, *args, **kwargs):
            pass

# AdaptiveEngine imports with fallback
try:
    from core.adaptive_engine import AdaptiveEngine, AdaptiveConfig, StrategyResult
    ADAPTIVE_ENGINE_AVAILABLE = True
except ImportError:
    ADAPTIVE_ENGINE_AVAILABLE = False
    # Fallback classes
    class AdaptiveEngine:
        def __init__(self, *args, **kwargs):
            pass
        async def find_best_strategy(self, *args, **kwargs):
            return None
    
    class AdaptiveConfig:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)
    
    class StrategyResult:
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)

# Enhanced error handling
try:
    from core.cli.error_handler import (
        CLIErrorHandler, ErrorSeverity, ErrorCategory, ErrorContext, handle_cli_error
    )
    ERROR_HANDLER_AVAILABLE = True
except ImportError:
    ERROR_HANDLER_AVAILABLE = False
    # Fallback error handling
    def handle_cli_error(error, *args, **kwargs):
        logging.error(f"Error: {error}")
        return False

LOG = logging.getLogger("AdaptiveCLIWrapper")


@dataclass
class CLIConfig:
    """CLI-specific configuration"""
    verbose: bool = False
    quiet: bool = False
    no_colors: bool = False
    export_file: Optional[str] = None
    save_legacy: bool = True
    show_progress: bool = True
    timeout: float = 300.0
    no_colors: bool = False
    export_file: Optional[str] = None
    save_legacy: bool = True
    show_progress: bool = True
    timeout: float = 300.0  # 5 minutes default timeout


class AdaptiveCLIWrapper:
    """
    Enhanced CLI wrapper for AdaptiveEngine with Rich output and error handling.
    
    Features:
    - Beautiful Rich-based progress display
    - Comprehensive error handling with graceful degradation
    - Parameter validation and normalization
    - Multiple output formats (console, JSON, legacy)
    - Timeout handling and cancellation support
    """
    
    def __init__(self, cli_config: Optional[CLIConfig] = None):
        self.cli_config = cli_config or CLIConfig()
        
        # Initialize console with appropriate settings
        self.console = self._create_console()
        
        # Initialize error handler
        if ERROR_HANDLER_AVAILABLE:
            self.error_handler = CLIErrorHandler(self.console, self.cli_config.verbose)
        else:
            self.error_handler = None
        
        # Initialize adaptive engine configuration
        self.config = AdaptiveConfig(
            max_trials=15,
            stop_on_success=True,
            enable_fingerprinting=True,
            enable_failure_analysis=True,
            mode="comprehensive",
            enable_caching=True,
            enable_parallel_testing=True,  # Ð’ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð´Ð¾Ð¼ÐµÐ½Ð¾Ð²
            max_parallel_workers=10
        )
        
        # Initialize adaptive engine if available
        self.engine = None
        self.engine_available = ADAPTIVE_ENGINE_AVAILABLE
        
        # Progress tracking
        self.current_progress = None
        self.progress_messages = []
        
    def _create_console(self) -> Console:
        """Create Rich console with appropriate settings"""
        if not RICH_AVAILABLE or self.cli_config.no_colors:
            return Console()
        
        return Console(
            highlight=False,
            force_terminal=not self.cli_config.quiet,
            width=None if sys.stdout.isatty() else 120
        )
    
    def _validate_domain(self, domain: str) -> str:
        """Validate and normalize domain name"""
        if not domain or not isinstance(domain, str):
            raise ValueError("Domain must be a non-empty string")
        
        domain = domain.strip().lower()
        
        # Remove protocol if present
        if domain.startswith(('http://', 'https://')):
            domain = domain.split('://', 1)[1]
        
        # Remove path if present
        if '/' in domain:
            domain = domain.split('/', 1)[0]
        
        # Basic domain validation
        if not domain or '.' not in domain:
            raise ValueError(f"Invalid domain format: {domain}")
        
        return domain
    
    def _create_adaptive_config(self, args) -> AdaptiveConfig:
        """Create AdaptiveConfig from CLI arguments"""
        config = AdaptiveConfig()
        
        # Map CLI arguments to config
        if hasattr(args, 'max_trials') and args.max_trials:
            config.max_trials = args.max_trials
        elif hasattr(args, 'mode'):
            mode_trials = {
                "quick": 5,
                "balanced": 10,
                "comprehensive": 15,
                "deep": 25
            }
            config.max_trials = mode_trials.get(args.mode, 10)
        
        if hasattr(args, 'no_fingerprinting'):
            config.enable_fingerprinting = not args.no_fingerprinting
        
        if hasattr(args, 'no_failure_analysis'):
            config.enable_failure_analysis = not args.no_failure_analysis
        
        # Set timeouts
        config.strategy_timeout = getattr(args, 'tls_timeout', 30.0)
        config.connection_timeout = getattr(args, 'connect_timeout', 5.0)
        
        # Set mode
        config.mode = getattr(args, 'mode', 'balanced')
        
        return config
    
    def _progress_callback(self, message: str):
        """Progress callback for AdaptiveEngine"""
        self.progress_messages.append({
            'timestamp': datetime.now(),
            'message': message
        })
        
        if not self.cli_config.quiet:
            if RICH_AVAILABLE:
                self.console.print(f"[cyan]{message}[/cyan]")
            else:
                print(f"[PROGRESS] {message}")
    
    def _display_startup_banner(self, domain: str, config: AdaptiveConfig):
        """Display startup banner with configuration"""
        if self.cli_config.quiet:
            return
        
        if RICH_AVAILABLE:
            panel_content = (
                f"[bold cyan]Recon: Adaptive Strategy Discovery[/bold cyan]\n"
                f"[dim]Target: {domain}[/dim]\n"
                f"[dim]Mode: {config.mode} (max {config.max_trials} trials)[/dim]\n"
                f"[dim]Fingerprinting: {'enabled' if config.enable_fingerprinting else 'disabled'}[/dim]\n"
                f"[dim]Failure Analysis: {'enabled' if config.enable_failure_analysis else 'disabled'}[/dim]"
            )
            
            self.console.print(Panel(panel_content, expand=False))
        else:
            print("="*60)
            print("Recon: Adaptive Strategy Discovery")
            print(f"Target: {domain}")
            print(f"Mode: {config.mode} (max {config.max_trials} trials)")
            print(f"Fingerprinting: {'enabled' if config.enable_fingerprinting else 'disabled'}")
            print(f"Failure Analysis: {'enabled' if config.enable_failure_analysis else 'disabled'}")
            print("="*60)
    
    def _display_results(self, result: StrategyResult, execution_time: float, stats: Dict[str, Any]):
        """Display analysis results with Rich formatting"""
        if RICH_AVAILABLE:
            self._display_results_rich(result, execution_time, stats)
        else:
            self._display_results_plain(result, execution_time, stats)
    
    def _display_results_rich(self, result: StrategyResult, execution_time: float, stats: Dict[str, Any]):
        """Display results using Rich formatting"""
        # Results header
        self.console.print("\n" + "="*60)
        self.console.print("[bold]ADAPTIVE ANALYSIS RESULTS[/bold]")
        self.console.print("="*60)
        
        # Success/failure status
        if result.success:
            self.console.print(f"[bold green]âœ… SUCCESS[/bold green]")
            if hasattr(result, 'strategy') and result.strategy:
                self.console.print(f"[green]Strategy: {result.strategy.name}[/green]")
                
                # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ attack_combination Ð²Ð¼ÐµÑÑ‚Ð¾ attack_name
                if hasattr(result.strategy, 'attack_combination') and result.strategy.attack_combination:
                    attacks = ", ".join(result.strategy.attack_combination)
                    self.console.print(f"[green]Attacks: {attacks}[/green]")
                elif hasattr(result.strategy, 'attack_name'):
                    self.console.print(f"[green]Attack: {result.strategy.attack_name}[/green]")
                
                if hasattr(result.strategy, 'parameters'):
                    self.console.print(f"[green]Parameters: {result.strategy.parameters}[/green]")
                
                # Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¾ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸
                if hasattr(result.strategy, 'expected_success_rate'):
                    rate = result.strategy.expected_success_rate
                    self.console.print(f"[green]Expected Success Rate: {rate:.1%}[/green]")
                
                if hasattr(result.strategy, 'rationale'):
                    self.console.print(f"[dim]Rationale: {result.strategy.rationale}[/dim]")
        else:
            self.console.print(f"[bold red]âŒ FAILED[/bold red]")
        
        self.console.print(f"[dim]Message: {result.message}[/dim]")
        
        # Performance metrics table
        metrics_table = Table(title="Performance Metrics", show_header=True)
        metrics_table.add_column("Metric", style="cyan")
        metrics_table.add_column("Value", style="green")
        
        metrics_table.add_row("Execution Time", f"{execution_time:.2f}s")
        metrics_table.add_row("Trials Performed", str(getattr(result, 'trials_count', 0)))
        metrics_table.add_row("Fingerprint Updated", str(getattr(result, 'fingerprint_updated', False)))
        
        self.console.print(metrics_table)
        
        # Engine statistics
        if stats:
            stats_table = Table(title="Engine Statistics", show_header=True)
            stats_table.add_column("Statistic", style="cyan")
            stats_table.add_column("Count", style="yellow")
            
            for key, value in stats.items():
                stats_table.add_row(key.replace('_', ' ').title(), str(value))
            
            self.console.print(stats_table)
    
    def _display_results_plain(self, result: StrategyResult, execution_time: float, stats: Dict[str, Any]):
        """Display results using plain text formatting"""
        print("\n" + "="*60)
        print("ADAPTIVE ANALYSIS RESULTS")
        print("="*60)
        
        if result.success:
            print("âœ… SUCCESS")
            if hasattr(result, 'strategy') and result.strategy:
                print(f"Strategy: {result.strategy.name}")
                print(f"Attack: {result.strategy.attack_name}")
                if hasattr(result.strategy, 'parameters'):
                    print(f"Parameters: {result.strategy.parameters}")
        else:
            print("âŒ FAILED")
        
        print(f"Message: {result.message}")
        print(f"\nExecution Time: {execution_time:.2f}s")
        print(f"Trials Performed: {getattr(result, 'trials_count', 0)}")
        print(f"Fingerprint Updated: {getattr(result, 'fingerprint_updated', False)}")
        
        if stats:
            print("\nEngine Statistics:")
            for key, value in stats.items():
                print(f"  {key.replace('_', ' ').title()}: {value}")
    
    def _export_results(self, domain: str, result: StrategyResult, execution_time: float, 
                       stats: Dict[str, Any], export_file: str):
        """Export results to JSON file"""
        try:
            export_data = {
                'timestamp': datetime.now().isoformat(),
                'domain': domain,
                'result': {
                    'success': result.success,
                    'message': result.message,
                    'execution_time': execution_time,
                    'trials_count': getattr(result, 'trials_count', 0),
                    'fingerprint_updated': getattr(result, 'fingerprint_updated', False)
                },
                'statistics': stats,
                'progress_log': self.progress_messages
            }
            
            # Add strategy details if available
            if result.success and hasattr(result, 'strategy') and result.strategy:
                export_data['result']['strategy'] = {
                    'name': result.strategy.name,
                    'attack_name': result.strategy.attack_name,
                    'parameters': getattr(result.strategy, 'parameters', {})
                }
            
            with open(export_file, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)
            
            if not self.cli_config.quiet:
                self.console.print(f"[green]âœ“ Results exported to: {export_file}[/green]")
            
        except Exception as e:
            LOG.error(f"Failed to export results: {e}")
            if not self.cli_config.quiet:
                self.console.print(f"[yellow]Warning: Failed to export results: {e}[/yellow]")
    
    def _save_legacy_strategy(self, domain: str, result: StrategyResult):
        """Save strategy in legacy format for compatibility"""
        if not (result.success and hasattr(result, 'strategy') and result.strategy):
            return
        
        try:
            # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ attack_name Ð¸Ð· attack_combination
            attack_name = "unknown"
            if hasattr(result.strategy, 'attack_combination') and result.strategy.attack_combination:
                attack_name = "_".join(result.strategy.attack_combination)
            elif hasattr(result.strategy, 'attack_name'):
                attack_name = result.strategy.attack_name
            
            legacy_strategy = {
                "domain": domain,
                "strategy": result.strategy.name,
                "attack_name": attack_name,
                "attacks": getattr(result.strategy, 'attack_combination', [attack_name]),
                "parameters": getattr(result.strategy, 'parameters', {}),
                "timestamp": datetime.now().isoformat(),
                "source": "adaptive_engine_cli"
            }
            
            legacy_file = "best_strategy.json"
            with open(legacy_file, 'w', encoding='utf-8') as f:
                json.dump(legacy_strategy, f, indent=2, ensure_ascii=False)
            
            if not self.cli_config.quiet:
                self.console.print(f"[green]âœ“ Strategy saved to: {legacy_file}[/green]")
                
        except Exception as e:
            LOG.error(f"Failed to save legacy strategy: {e}")
            if not self.cli_config.quiet:
                self.console.print(f"[yellow]Warning: Failed to save legacy strategy: {e}[/yellow]")
    
    async def run_batch_adaptive_analysis(self, domains: List[str], args) -> Dict[str, bool]:
        """
        Ð—Ð°Ð¿ÑƒÑÐº Ð¿Ð°ÐºÐµÑ‚Ð½Ð¾Ð³Ð¾ Ð°Ð´Ð°Ð¿Ñ‚Ð¸Ð²Ð½Ð¾Ð³Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° Ñ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸ÐµÐ¹:
        Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÐµÑ‚ Ð¾Ð´Ð½Ñƒ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸ÑŽ Ð½Ð° Ð²ÑÐµÑ… Ð´Ð¾Ð¼ÐµÐ½Ð°Ñ… Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾.
        
        Args:
            domains: Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð´Ð¾Ð¼ÐµÐ½Ð¾Ð² Ð´Ð»Ñ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°
            args: CLI Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹
            
        Returns:
            Dict[str, bool]: Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° {domain: success}
        """
        if not domains:
            return {}
        
        self.console.print(f"\n[bold blue]ðŸš€ ÐŸÐ°ÐºÐµÑ‚Ð½Ñ‹Ð¹ Ð°Ð´Ð°Ð¿Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð°Ð½Ð°Ð»Ð¸Ð· {len(domains)} Ð´Ð¾Ð¼ÐµÐ½Ð¾Ð²[/bold blue]")
        self.console.print("[dim]ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ: Ð¾Ð´Ð½Ð° ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ â†’ Ð²ÑÐµ Ð´Ð¾Ð¼ÐµÐ½Ñ‹ Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾[/dim]")
        
        # Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÐ¼ Ð´Ð²Ð¸Ð¶Ð¾Ðº
        if not hasattr(self, 'engine') or not self.engine:
            self.engine = AdaptiveEngine(self.config)
        
        all_results = {}
        
        # Ð”Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð´Ð¾Ð¼ÐµÐ½Ð° Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸ (Ð±ÐµÑ€ÐµÐ¼ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð´Ð¾Ð¼ÐµÐ½ ÐºÐ°Ðº Ð¾Ð±Ñ€Ð°Ð·ÐµÑ†)
        sample_domain = domains[0]
        
        try:
            # Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ Ð´Ð¾Ð¼ÐµÐ½Ð°
            self.console.print(f"[dim]Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ {sample_domain}...[/dim]")
            
            # ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ fingerprint Ð¸ Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸
            try:
                fingerprint = self.engine.fingerprint_service.get_or_create(sample_domain)
                intents = self.engine.intent_engine.propose_intents(fingerprint)
                strategies = self.engine.strategy_generator.generate_strategies_from_intents(
                    intents[:10], fingerprint  # ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ð²Ð°ÐµÐ¼ Ð´Ð¾ 10 ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹
                )
            except Exception as e:
                self.console.print(f"[yellow]âš ï¸ ÐžÑˆÐ¸Ð±ÐºÐ° Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹: {e}[/yellow]")
                self.console.print("[dim]Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸...[/dim]")
                # Fallback Ðº Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¼ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸ÑÐ¼
                strategies = self._get_fallback_strategies()
            
            if not strategies:
                self.console.print("[red]âŒ ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸[/red]")
                return {domain: False for domain in domains}
            
            self.console.print(f"[green]âœ“ Ð¡Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ {len(strategies)} ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹[/green]")
            
            # Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ°Ð¶Ð´ÑƒÑŽ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸ÑŽ Ð½Ð° Ð²ÑÐµÑ… Ð´Ð¾Ð¼ÐµÐ½Ð°Ñ… Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾
            for i, strategy in enumerate(strategies, 1):
                self.console.print(f"\n[bold]ðŸ“Š Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ {i}/{len(strategies)}: {strategy.name}[/bold]")
                
                # Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÐµÐ¼ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸ÑŽ Ð½Ð° Ð²ÑÐµÑ… Ð´Ð¾Ð¼ÐµÐ½Ð°Ñ… Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾
                strategy_results = await self.engine.test_strategy_on_multiple_domains(
                    domains, strategy, progress_callback=self.console.print
                )
                
                # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ‰Ð¸Ðµ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹
                for domain, success in strategy_results.items():
                    if domain not in all_results or not all_results[domain]:
                        all_results[domain] = success
                
                # ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ ÑÑ‚Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸
                successful_domains = [d for d, s in strategy_results.items() if s]
                if successful_domains:
                    self.console.print(f"[green]âœ… Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ ÑÑ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð° Ð´Ð»Ñ {len(successful_domains)} Ð´Ð¾Ð¼ÐµÐ½Ð¾Ð²:[/green]")
                    for domain in successful_domains:
                        self.console.print(f"  â€¢ {domain}")
                else:
                    self.console.print(f"[red]âŒ Ð¡Ñ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ Ð½Ðµ ÑÑ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð° Ð½Ð¸ Ð´Ð»Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð´Ð¾Ð¼ÐµÐ½Ð°[/red]")
                
                # Ð•ÑÐ»Ð¸ Ð²ÑÐµ Ð´Ð¾Ð¼ÐµÐ½Ñ‹ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹, Ð¼Ð¾Ð¶Ð½Ð¾ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒÑÑ
                if all(all_results.get(d, False) for d in domains):
                    self.console.print(f"[green]ðŸŽ‰ Ð’ÑÐµ Ð´Ð¾Ð¼ÐµÐ½Ñ‹ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ñ‹![/green]")
                    break
            
            # Ð˜Ñ‚Ð¾Ð³Ð¾Ð²Ð°Ñ ÑÐ²Ð¾Ð´ÐºÐ°
            successful_domains = [d for d, s in all_results.items() if s]
            failed_domains = [d for d, s in all_results.items() if not s]
            
            self.console.print(f"\n[bold blue]ðŸ“Š Ð˜Ñ‚Ð¾Ð³Ð¾Ð²Ð°Ñ ÑÐ²Ð¾Ð´ÐºÐ° Ð¿Ð°ÐºÐµÑ‚Ð½Ð¾Ð³Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°[/bold blue]")
            self.console.print(f"[green]âœ… Ð£ÑÐ¿ÐµÑˆÐ½Ð¾: {len(successful_domains)}/{len(domains)}[/green]")
            self.console.print(f"[red]âŒ ÐÐµÑƒÐ´Ð°Ñ‡Ð½Ð¾: {len(failed_domains)}/{len(domains)}[/red]")
            
            return all_results
            
        except Exception as e:
            LOG.error(f"Batch analysis error: {e}")
            self.console.print(f"[red]âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð°ÐºÐµÑ‚Ð½Ð¾Ð³Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°: {e}[/red]")
            return {domain: False for domain in domains}
    
    def _get_fallback_strategies(self):
        """ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ñ… ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¹ Ð² ÑÐ»ÑƒÑ‡Ð°Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸"""
        try:
            # Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Strategy ÐµÑÐ»Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½
            from core.strategy_failure_analyzer import Strategy
            
            # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ðµ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ð¸
            fallback_strategies = [
                Strategy(
                    name="fake_ttl3",
                    attack_name="fake",
                    parameters={"ttl": 3, "split_pos": "sni"}
                ),
                Strategy(
                    name="disorder_ttl4", 
                    attack_name="disorder",
                    parameters={"ttl": 4, "split_pos": 3}
                ),
                Strategy(
                    name="split2_ttl5",
                    attack_name="split2",
                    parameters={"ttl": 5, "split_pos": 2}
                )
            ]
            
            return fallback_strategies
            
        except ImportError:
            # Ð•ÑÐ»Ð¸ Strategy Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½, Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ Ð¿ÑƒÑÑ‚Ð¾Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº
            return []
    
    async def run_adaptive_analysis(self, domain: str, args) -> bool:
        """
        Run adaptive analysis with enhanced CLI integration.
        
        Args:
            domain: Target domain name
            args: CLI arguments object
            
        Returns:
            bool: True if analysis was successful, False otherwise
        """
        try:
            # Validate domain
            domain = self._validate_domain(domain)
            
        except ValueError as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    e, 
                    ErrorSeverity.ERROR,
                    ErrorContext(
                        operation="domain_validation",
                        component="AdaptiveCLIWrapper",
                        user_action=f"validating domain '{domain}'"
                    )
                )
            else:
                self.console.print(f"[bold red]Error: {e}[/bold red]")
            return False
        
        # Check if AdaptiveEngine is available
        if not self.engine_available:
            error = ImportError("AdaptiveEngine components not available")
            if self.error_handler:
                self.error_handler.handle_error(
                    error,
                    ErrorSeverity.CRITICAL,
                    ErrorContext(
                        operation="adaptive_engine_initialization",
                        component="AdaptiveCLIWrapper",
                        user_action="initializing adaptive analysis",
                        suggestions=[
                            "Check if core.adaptive_engine module is installed",
                            "Verify all dependencies are available",
                            "Try running in legacy mode"
                        ]
                    )
                )
            else:
                self.console.print(
                    "[bold red]Error: AdaptiveEngine components not available[/bold red]"
                )
                self.console.print(
                    "[yellow]Please ensure all required modules are installed[/yellow]"
                )
            return False
        
        # Create adaptive configuration
        try:
            config = self._create_adaptive_config(args)
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    e,
                    ErrorSeverity.ERROR,
                    ErrorContext(
                        operation="configuration_creation",
                        component="AdaptiveCLIWrapper",
                        user_action="creating adaptive configuration from CLI arguments"
                    )
                )
            else:
                self.console.print(f"[bold red]Error creating configuration: {e}[/bold red]")
            return False
        
        # Display startup banner
        self._display_startup_banner(domain, config)
        
        # Initialize AdaptiveEngine
        try:
            self.engine = AdaptiveEngine(config)
            if not self.cli_config.quiet:
                self.console.print("[green]âœ“ AdaptiveEngine initialized[/green]")
                
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    e,
                    ErrorSeverity.CRITICAL,
                    ErrorContext(
                        operation="adaptive_engine_initialization",
                        component="AdaptiveEngine",
                        user_action="initializing AdaptiveEngine with configuration",
                        debug_info={
                            "config_mode": getattr(config, 'mode', 'unknown'),
                            "max_trials": getattr(config, 'max_trials', 'unknown'),
                            "fingerprinting": getattr(config, 'enable_fingerprinting', 'unknown')
                        }
                    )
                )
            else:
                self.console.print(f"[bold red]Error initializing AdaptiveEngine: {e}[/bold red]")
                if self.cli_config.verbose:
                    import traceback
                    traceback.print_exc()
            return False
        
        # Run analysis with timeout and progress tracking
        start_time = time.time()
        result = None
        
        try:
            # Create progress display
            if RICH_AVAILABLE and self.cli_config.show_progress and not self.cli_config.quiet:
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    BarColumn(),
                    TimeElapsedColumn(),
                    console=self.console,
                    transient=True
                ) as progress:
                    task = progress.add_task("[cyan]Running adaptive analysis...", total=None)
                    
                    # Run analysis with timeout
                    result = await asyncio.wait_for(
                        self.engine.find_best_strategy(domain, self._progress_callback),
                        timeout=self.cli_config.timeout
                    )
                    
                    progress.update(task, completed=True)
            else:
                # Run without progress display
                if not self.cli_config.quiet:
                    print("Running adaptive analysis...")
                
                result = await asyncio.wait_for(
                    self.engine.find_best_strategy(domain, self._progress_callback),
                    timeout=self.cli_config.timeout
                )
            
        except asyncio.TimeoutError:
            timeout_error = TimeoutError(f"Analysis timed out after {self.cli_config.timeout}s")
            if self.error_handler:
                self.error_handler.handle_error(
                    timeout_error,
                    ErrorSeverity.ERROR,
                    ErrorContext(
                        operation="adaptive_analysis",
                        component="AdaptiveEngine",
                        user_action=f"running adaptive analysis for {domain}",
                        suggestions=[
                            "Try with --mode quick for faster analysis",
                            "Increase timeout or reduce --max-trials",
                            "Check network connectivity and stability"
                        ]
                    )
                )
            else:
                self.console.print(
                    f"[bold red]Error: Analysis timed out after {self.cli_config.timeout}s[/bold red]"
                )
            return False
            
        except Exception as e:
            if self.error_handler:
                self.error_handler.handle_error(
                    e,
                    ErrorSeverity.ERROR,
                    ErrorContext(
                        operation="adaptive_analysis",
                        component="AdaptiveEngine",
                        user_action=f"running adaptive analysis for {domain}",
                        debug_info={
                            "domain": domain,
                            "timeout": self.cli_config.timeout,
                            "progress_messages": len(self.progress_messages)
                        }
                    )
                )
            else:
                self.console.print(f"[bold red]Error during analysis: {e}[/bold red]")
                if self.cli_config.verbose:
                    import traceback
                    traceback.print_exc()
            return False
        
        execution_time = time.time() - start_time
        
        # Get engine statistics
        stats = {}
        try:
            if self.engine:
                stats = self.engine.get_stats()
        except Exception as e:
            LOG.warning(f"Failed to get engine stats: {e}")
        
        # Display results
        if result:
            self._display_results(result, execution_time, stats)
            
            # Export results if requested
            if self.cli_config.export_file:
                self._export_results(domain, result, execution_time, stats, self.cli_config.export_file)
            
            # Save legacy strategy if requested
            if self.cli_config.save_legacy:
                self._save_legacy_strategy(domain, result)
            
            # Display error summary if error handler is available
            if self.error_handler:
                self.error_handler.display_summary()
            
            return result.success
        else:
            error_msg = "No result returned from analysis"
            if self.error_handler:
                no_result_error = RuntimeError(error_msg)
                self.error_handler.handle_error(
                    no_result_error,
                    ErrorSeverity.ERROR,
                    ErrorContext(
                        operation="adaptive_analysis",
                        component="AdaptiveEngine",
                        user_action=f"getting analysis results for {domain}"
                    )
                )
            else:
                self.console.print(f"[bold red]Error: {error_msg}[/bold red]")
            return False


def create_cli_wrapper_from_args(args) -> AdaptiveCLIWrapper:
    """Create AdaptiveCLIWrapper from CLI arguments"""
    cli_config = CLIConfig(
        verbose=getattr(args, 'debug', False),
        quiet=getattr(args, 'quiet', False),
        no_colors=not RICH_AVAILABLE,
        export_file=getattr(args, 'export_results', None),
        save_legacy=True,  # Always save for compatibility
        show_progress=True,
        timeout=300.0  # 5 minutes default
    )
    
    return AdaptiveCLIWrapper(cli_config)