# Multisplit Attack Specification
# Splits packet into multiple segments at specified positions

name: multisplit
aliases:
  - tcp_multisplit
description: Split packet into multiple segments at specified positions
category: tcp_fragmentation

parameters:
  - name: split_positions
    type: list[int]
    default: null
    required: true
    description: List of byte positions where to split the packet
  
  - name: num_splits
    type: int
    default: null
    min: 2
    max: 10
    required: false
    description: Number of equal-sized splits (alternative to split_positions)
  
  - name: segment_size
    type: int
    default: null
    min: 1
    required: false
    description: Size of each segment in bytes (alternative to split_positions)

expected_packets:
  count: "{len(split_positions) + 1 or num_splits}"
  order:
    - packet_index: 0
      name: segment_0
      properties:
        seq: "{original_seq}"
        length: "{split_positions[0]}"
        tcp_flags: "PSH+ACK (0x18)"
        payload: "original_payload[0:split_positions[0]]"
    
    - packet_index: 1
      name: segment_1
      properties:
        seq: "{original_seq + split_positions[0]}"
        length: "{split_positions[1] - split_positions[0]}"
        tcp_flags: "PSH+ACK (0x18)"
        payload: "original_payload[split_positions[0]:split_positions[1]]"
    
    - packet_index: "..."
      name: segment_n
      properties:
        seq: "{original_seq + split_positions[n-1]}"
        length: "{len(original_payload) - split_positions[n-1]}"
        tcp_flags: "PSH+ACK (0x18)"
        payload: "original_payload[split_positions[n-1]:]"

validation_rules:
  sequence_numbers:
    - rule: "segments[0].seq == original_seq"
      description: "First segment must start at original sequence number"
      severity: critical
    
    - rule: "for i in range(1, len(segments)): segments[i].seq == segments[i-1].seq + len(segments[i-1].payload)"
      description: "Each segment sequence must follow previous segment"
      severity: critical
  
  payload:
    - rule: "b''.join(s.payload for s in segments) == original_payload"
      description: "Combined payload must equal original"
      severity: critical
    
    - rule: "sum(len(s.payload) for s in segments) == len(original_payload)"
      description: "Total segment lengths must equal original length"
      severity: critical
  
  packet_count:
    - rule: "if params.split_positions: len(packets) == len(params.split_positions) + 1"
      description: "Must generate correct number of packets based on split positions"
      severity: critical
    
    - rule: "if params.num_splits: len(packets) == params.num_splits"
      description: "Must generate correct number of packets based on num_splits"
      severity: critical
  
  packet_order:
    - rule: "for i in range(len(packets)-1): packets[i].seq < packets[i+1].seq"
      description: "Packets must be in sequence order"
      severity: critical
  
  checksum:
    - rule: "all(p.checksum_valid for p in packets)"
      description: "All packets must have valid checksums"
      severity: critical
  
  ttl:
    - rule: "all(p.ttl in [64, 128] for p in packets)"
      description: "All packets should have default system TTL"
      severity: warning

test_variations:
  two_splits:
    description: "Split into 2 segments"
    params:
      split_positions: [50]
  
  three_splits:
    description: "Split into 3 segments"
    params:
      split_positions: [30, 60]
  
  many_splits:
    description: "Split into many small segments"
    params:
      split_positions: [1, 2, 3, 4, 5, 10, 20, 30]
  
  equal_splits:
    description: "Split into equal-sized segments"
    params:
      num_splits: 4
  
  small_segments:
    description: "Split into small fixed-size segments"
    params:
      segment_size: 10

error_cases:
  missing_params:
    description: "Must specify split_positions, num_splits, or segment_size"
    params: {}
    expected_error: "Must specify split_positions, num_splits, or segment_size"
  
  invalid_split_positions:
    description: "Split positions must be sorted and positive"
    params:
      split_positions: [50, 30, 10]
    expected_error: "split_positions must be sorted in ascending order"
  
  too_many_splits:
    description: "Cannot have too many splits"
    params:
      num_splits: 100
    expected_error: "num_splits must be <= 10"
  
  zero_segment_size:
    description: "Segment size must be positive"
    params:
      segment_size: 0
    expected_error: "segment_size must be >= 1"

notes:
  - "Splits packet into multiple segments"
  - "All segments have valid checksums and sequential sequence numbers"
  - "No TTL manipulation - all packets reach destination"
  - "Useful for breaking up large DPI signatures"
  - "Can specify exact split positions or use automatic splitting"
  - "split_positions: list of byte positions [10, 20, 30]"
  - "num_splits: number of equal-sized segments"
  - "segment_size: size of each segment (last may be smaller)"
  - "Maximum 10 splits recommended for performance"
