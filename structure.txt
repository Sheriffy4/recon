Теперь я вижу полную картину всех движков. Вот финальный план рефакторинга всей системы:

## Полная архитектура системы движков:

```
recon/
├── core/
│   ├── bypass/
│   │   ├── __init__.py
│   │   ├── attacks/
│   │   │   ├── __init__.py
│   │   │   ├── base.py              # Базовый класс атак
│   │   │   ├── registry.py          # Реестр атак
│   │   │   ├── tcp/                 # TCP атаки
│   │   │   ├── ip/                  # IP атаки
│   │   │   ├── http/                # HTTP атаки
│   │   │   ├── tls/                 # TLS атаки
│   │   │   ├── timing/              # Timing атаки
│   │   │   ├── tunneling/           # Туннелирование
│   │   │   └── combo/               # Комбо атаки
│   │   ├── engines/
│   │   │   ├── __init__.py
│   │   │   ├── base.py              # Базовый движок
│   │   │   ├── factory.py           # Фабрика движков
│   │   │   ├── local/               # Локальные движки
│   │   │   │   ├── scapy_engine.py  # Scapy-based
│   │   │   │   └── socket_engine.py # Socket-based
│   │   │   ├── system/              # Системные движки
│   │   │   │   ├── pydivert_engine.py
│   │   │   │   ├── netfilter_engine.py (Linux)
│   │   │   │   └── windivert_wrapper.py
│   │   │   ├── hybrid_engine.py
│   │   │   └── test_engine.py       # Для тестирования
│   │   ├── network/
│   │   │   ├── __init__.py
│   │   │   ├── session_manager.py   # TCP/UDP сессии
│   │   │   ├── packet_interceptor.py # Перехват пакетов
│   │   │   ├── rate_limiter.py
│   │   │   └── response_analyzer.py
│   │   ├── protocols/
│   │   │   ├── __init__.py
│   │   │   ├── tls.py
│   │   │   ├── http.py
│   │   │   ├── quic.py
│   │   │   └── dns.py
│   │   ├── strategies/
│   │   │   ├── __init__.py
│   │   │   ├── parser.py
│   │   │   ├── executor.py
│   │   │   └── generator.py
│   │   └── testing/
│   │       ├── __init__.py
│   │       ├── real_world_tester.py
│   │       └── connectivity_checker.py
```

## Детальный рефакторинг:

### 1. Унифицированный интерфейс движков

```python
# recon/core/bypass/engines/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, Set
from dataclasses import dataclass
import asyncio
import threading

@dataclass
class EngineCapabilities:
    """Возможности движка."""
    supports_tcp: bool = True
    supports_udp: bool = False
    supports_system_intercept: bool = False
    supports_async: bool = False
    requires_admin: bool = False
    platforms: List[str] = None
    
@dataclass
class EngineConfig:
    """Конфигурация движка."""
    debug: bool = False
    rate_limit: int = 20
    timeout: float = 5.0
    max_concurrent: int = 10

class BaseEngine(ABC):
    """Базовый класс для всех движков обхода."""
    
    def __init__(self, config: EngineConfig = None):
        self.config = config or EngineConfig()
        self.running = False
        self._thread = None
        
    @abstractmethod
    def get_capabilities(self) -> EngineCapabilities:
        """Возвращает возможности движка."""
        pass
        
    @abstractmethod
    def start(self, targets: Set[str], strategy_map: Dict[str, Any]) -> bool:
        """Запускает движок."""
        pass
        
    @abstractmethod
    def stop(self) -> bool:
        """Останавливает движок."""
        pass
        
    @abstractmethod
    def execute_strategy(self, ip: str, port: int, domain: str, 
                        strategy: str) -> Tuple[str, float]:
        """Выполняет стратегию для конкретного соединения."""
        pass
        
    def is_available(self) -> bool:
        """Проверяет доступность движка в текущей системе."""
        import platform
        capabilities = self.get_capabilities()
        
        if capabilities.platforms:
            current_platform = platform.system().lower()
            if current_platform not in [p.lower() for p in capabilities.platforms]:
                return False
                
        if capabilities.requires_admin:
            # Проверка прав администратора
            try:
                import os
                return os.geteuid() == 0 if hasattr(os, 'geteuid') else True
            except:
                return True
                
        return True
```

### 2. Унифицированный перехватчик пакетов

```python
# recon/core/bypass/network/packet_interceptor.py
from abc import ABC, abstractmethod
from typing import Callable, Optional, Any
import threading
import queue

class PacketInterceptor(ABC):
    """Базовый класс для перехвата пакетов."""
    
    def __init__(self, filter_expr: str):
        self.filter_expr = filter_expr
        self.running = False
        self._thread = None
        self._packet_queue = queue.Queue(maxsize=1000)
        
    @abstractmethod
    def start(self) -> bool:
        """Начать перехват."""
        pass
        
    @abstractmethod
    def stop(self) -> bool:
        """Остановить перехват."""
        pass
        
    @abstractmethod
    def send_packet(self, packet: Any) -> bool:
        """Отправить пакет."""
        pass
        
    def set_packet_handler(self, handler: Callable[[Any], List[Any]]):
        """Установить обработчик пакетов."""
        self.packet_handler = handler

class PyDivertInterceptor(PacketInterceptor):
    """Перехватчик для Windows через PyDivert."""
    
    def __init__(self, filter_expr: str):
        super().__init__(filter_expr)
        self._handle = None
        
    def start(self) -> bool:
        try:
            import pydivert
            self._handle = pydivert.WinDivert(self.filter_expr)
            self._handle.open()
            self.running = True
            
            self._thread = threading.Thread(
                target=self._intercept_loop,
                daemon=True
            )
            self._thread.start()
            return True
            
        except Exception as e:
            logging.error(f"Failed to start PyDivert: {e}")
            return False
            
    def _intercept_loop(self):
        """Цикл перехвата пакетов."""
        while self.running:
            try:
                packet = self._handle.recv()
                if packet and self.packet_handler:
                    # Обрабатываем пакет
                    modified_packets = self.packet_handler(packet)
                    
                    # Отправляем модифицированные пакеты
                    for mod_packet in modified_packets:
                        self.send_packet(mod_packet)
                else:
                    # Просто пересылаем
                    self.send_packet(packet)
                    
            except Exception as e:
                if self.running:
                    logging.debug(f"Packet intercept error: {e}")
                    
    def send_packet(self, packet: Any) -> bool:
        try:
            if self._handle:
                self._handle.send(packet)
                return True
        except:
            return False
            
    def stop(self) -> bool:
        self.running = False
        if self._thread:
            self._thread.join(timeout=2.0)
        if self._handle:
            self._handle.close()
        return True

class ScapyInterceptor(PacketInterceptor):
    """Перехватчик через Scapy (для локального тестирования)."""
    
    def start(self) -> bool:
        # Scapy не поддерживает настоящий перехват
        # Используется только для отправки
        self.running = True
        return True
        
    def send_packet(self, packet: Any) -> bool:
        try:
            from scapy.all import send
            send(packet, verbose=0)
            return True
        except:
            return False
            
    def stop(self) -> bool:
        self.running = False
        return True
```

### 3. Менеджер сессий

```python
# recon/core/bypass/network/session_manager.py
from typing import Dict, Optional, Tuple
import asyncio
import random
import time

class SessionManager:
    """Управляет сетевыми сессиями."""
    
    def __init__(self):
        self.tcp_sessions: Dict[Tuple[str, int], TCPSession] = {}
        self.udp_sessions: Dict[Tuple[str, int], UDPSession] = {}
        
    def get_tcp_session(self, dst: str, port: int) -> 'TCPSession':
        """Получить или создать TCP сессию."""
        key = (dst, port)
        if key not in self.tcp_sessions:
            self.tcp_sessions[key] = TCPSession(dst, port)
        return self.tcp_sessions[key]
        
    def close_all(self):
        """Закрыть все сессии."""
        for session in self.tcp_sessions.values():
            session.close()
        for session in self.udp_sessions.values():
            session.close()
        self.tcp_sessions.clear()
        self.udp_sessions.clear()

class TCPSession:
    """TCP сессия."""
    
    def __init__(self, dst: str, dport: int):
        self.dst = dst
        self.dport = dport
        self.sport = random.randint(49152, 65535)
        self.seq = random.randint(0, 2**32 - 1)
        self.ack = 0
        self.state = "CLOSED"
        self.last_activity = time.time()
        
    async def connect(self) -> bool:
        """Установить соединение (async версия)."""
        # Реализация TCP handshake
        pass
        
    def send_data(self, data: bytes) -> bool:
        """Отправить данные."""
        if self.state != "ESTABLISHED":
            return False
        # Отправка данных
        self.last_activity = time.time()
        return True
        
    def close(self):
        """Закрыть соединение."""
        if self.state == "ESTABLISHED":
            # Отправить FIN или RST
            pass
        self.state = "CLOSED"
```

### 4. Унифицированный движок с системным перехватом

```python
# recon/core/bypass/engines/system/pydivert_engine.py
from ..base import BaseEngine, EngineCapabilities, EngineConfig
from ...network.packet_interceptor import PyDivertInterceptor
from ...attacks.attack_registry import attack_registry
from ...strategies.parser import StrategyParser
import logging

class PyDivertEngine(BaseEngine):
    """Движок с системным перехватом через PyDivert."""
    
    def get_capabilities(self) -> EngineCapabilities:
        return EngineCapabilities(
            supports_tcp=True,
            supports_udp=True,
            supports_system_intercept=True,
            requires_admin=True,
            platforms=['Windows']
        )
        
    def __init__(self, config: EngineConfig = None):
        super().__init__(config)
        self.interceptor = None
        self.parser = StrategyParser()
        self.logger = logging.getLogger("PyDivertEngine")
        
    def start(self, targets: Set[str], strategy_map: Dict[str, Any]) -> bool:
        """Запуск движка с перехватом пакетов."""
        if self.running:
            return False
            
        # Создаем фильтр для целевых IP
        filter_parts = []
        for ip in targets:
            filter_parts.append(f"ip.DstAddr == {ip}")
            
        filter_expr = f"outbound and tcp and ({' or '.join(filter_parts)})"
        
        # Создаем перехватчик
        self.interceptor = PyDivertInterceptor(filter_expr)
        
        # Устанавливаем обработчик
        self.interceptor.set_packet_handler(
            lambda pkt: self._handle_packet(pkt, strategy_map)
        )
        
        # Запускаем
        if self.interceptor.start():
            self.running = True
            self.logger.info("PyDivert engine started")
            return True
        return False
        
    def _handle_packet(self, packet: Any, strategy_map: Dict[str, Any]) -> List[Any]:
        """Обработчик перехваченных пакетов."""
        try:
            # Определяем, нужно ли обрабатывать
            if not self._should_process(packet):
                return [packet]
                
            # Получаем стратегию
            strategy = strategy_map.get(packet.dst_addr)
            if not strategy:
                return [packet]
                
            # Применяем стратегию
            return self._apply_strategy(packet, strategy)
            
        except Exception as e:
            self.logger.error(f"Packet handling error: {e}")
            return [packet]
            
    def _should_process(self, packet: Any) -> bool:
        """Определить, нужно ли обрабатывать пакет."""
        # Проверяем, что это исходящий TCP пакет с данными
        return (packet.is_outbound and 
                hasattr(packet, 'tcp') and 
                packet.tcp and 
                packet.payload)
                
    def _apply_strategy(self, packet: Any, strategy: Dict) -> List[Any]:
        """Применить стратегию к пакету."""
        # Парсим стратегию
        attack_config = self.parser.parse_strategy(strategy)
        
        # Получаем атаку из реестра
        attack = attack_registry.create(
            attack_config['type'],
            rate_limiter=None  # Не нужен для системного перехвата
        )
        
        if not attack:
            return [packet]
            
        # Применяем атаку
        # ... логика применения ...
        
        return modified_packets
        
    def stop(self) -> bool:
        """Остановка движка."""
        if self.interceptor:
            self.interceptor.stop()
        self.running = False
        return True
```

### 5. Тестировщик реального мира

```python
# recon/core/bypass/testing/real_world_tester.py
from typing import List, Dict, Tuple, Optional
import asyncio
import aiohttp
from ..engines.factory import EngineFactory

class RealWorldTester:
    """Тестирование стратегий на реальных сайтах."""
    
    def __init__(self, engine_type: str = 'auto'):
        self.engine = EngineFactory.create(engine_type)
        self.session = None
        
    async def test_connectivity(self, sites: List[str], 
                              timeout: float = 5.0) -> Dict[str, TestResult]:
        """Тестировать доступность сайтов."""
        async with aiohttp.ClientSession() as session:
            tasks = []
            for site in sites:
                task = self._test_single_site(session, site, timeout)
                tasks.append(task)
                
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            return dict(zip(sites, results))
            
    async def _test_single_site(self, session: aiohttp.ClientSession,
                               site: str, timeout: float) -> TestResult:
        """Тестировать один сайт."""
        try:
            start_time = asyncio.get_event_loop().time()
            
            async with session.get(
                site, 
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as response:
                latency = (asyncio.get_event_loop().time() - start_time) * 1000
                
                return TestResult(
                    status="WORKING",
                    http_code=response.status,
                    latency_ms=latency
                )
                
        except asyncio.TimeoutError:
            return TestResult(status="TIMEOUT")
        except Exception as e:
            return TestResult(status="ERROR", error=str(e))
            
    async def test_strategy(self, strategy: str, sites: List[str],
                          target_ips: Set[str]) -> StrategyTestResult:
        """Тестировать стратегию на сайтах."""
        # Базовый тест без обхода
        baseline = await self.test_connectivity(sites)
        
        # Запускаем движок со стратегией
        strategy_map = {'default': self._parse_strategy(strategy)}
        if not self.engine.start(target_ips, strategy_map):
            return StrategyTestResult(
                success=False,
                error="Failed to start engine"
            )
            
        try:
            # Даем время на инициализацию
            await asyncio.sleep(1.0)
            
            # Тест со стратегией
            with_strategy = await self.test_connectivity(sites)
            
            # Анализируем результаты
            improved = 0
            for site in sites:
                if (baseline[site].status != "WORKING" and 
                    with_strategy[site].status == "WORKING"):
                    improved += 1
                    
            return StrategyTestResult(
                success=True,
                baseline_results=baseline,
                strategy_results=with_strategy,
                improved_count=improved,
                total_count=len(sites)
            )
            
        finally:
            self.engine.stop()
```

### 6. Туннелирование

```python
# recon/core/bypass/attacks/tunneling/quic_attack.py
from ..base import BaseAttack, AttackContext, AttackResult
from ..registry import register_attack
from ....protocols.quic import QUICProtocol

@register_attack("quic_frag")
class QUICFragmentationAttack(BaseAttack):
    """QUIC фрагментация."""
    
    def get_name(self) -> str:
        return "QUIC Fragmentation"
        
    def execute(self, context: AttackContext, split_pos: int = 100, 
                **params) -> AttackResult:
        """Выполнить QUIC фрагментацию."""
        try:
            # Создаем QUIC Initial пакет
            quic_initial = QUICProtocol.create_initial_packet(
                context.domain
            )
            
            # Фрагментируем
            if split_pos >= len(quic_initial):
                return AttackResult(
                    status="INVALID_PARAMS",
                    latency=0.0
                )
                
            fragments = [
                quic_initial[:split_pos],
                quic_initial[split_pos:]
            ]
            
            # Отправляем фрагменты
            for i, fragment in enumerate(fragments):
                packet = self._build_udp_packet(
                    context.dst,
                    context.port,
                    fragment
                )
                
                if i < len(fragments) - 1:
                    self._send_packet(packet)
                    time.sleep(0.02)
                else:
                    response = self._send_and_receive(packet)
                    
            # Анализируем ответ
            if response and response.haslayer(UDP):
                return AttackResult(status="SUCCESS", latency=0.0)
            else:
                return AttackResult(status="TIMEOUT", latency=0.0)
                
        except Exception as e:
            return AttackResult(
                status="ENGINE_ERROR",
                latency=0.0,
                metadata={'error': str(e)}
            )
```

### 7. Фабрика движков

```python
# recon/core/bypass/engines/factory.py
from typing import Dict, Type, Optional, List
from .base import BaseEngine
import platform
import importlib
import logging

class EngineFactory:
    """Фабрика для создания движков."""
    
    _engines: Dict[str, Type[BaseEngine]] = {}
    _logger = logging.getLogger("EngineFactory")
    
    @classmethod
    def register(cls, name: str, engine_class: Type[BaseEngine]):
        """Регистрация движка."""
        cls._engines[name] = engine_class
        
    @classmethod
    def create(cls, engine_type: str = 'auto', **kwargs) -> BaseEngine:
        """Создание движка."""
        if engine_type == 'auto':
            engine_type = cls._detect_best_engine()
            
        engine_class = cls._engines.get(engine_type)
        if not engine_class:
            raise ValueError(f"Unknown engine: {engine_type}")
            
        engine = engine_class(**kwargs)
        
        if not engine.is_available():
            raise RuntimeError(f"Engine {engine_type} not available")
            
        return engine
        
    @classmethod
    def _detect_best_engine(cls) -> str:
        """Определение лучшего движка для системы."""
        system = platform.system()
        
        # Приоритеты по платформам
        if system == 'Windows':
            priorities = ['pydivert', 'scapy', 'socket']
        elif system == 'Linux':
            priorities = ['netfilter', 'scapy', 'socket']
        else:
            priorities = ['scapy', 'socket']
            
        # Проверяем доступность
        for engine_name in priorities:
            if engine_name in cls._engines:
                engine_class = cls._engines[engine_name]
                try:
                    test_engine = engine_class()
                    if test_engine.is_available():
                        cls._logger.info(f"Auto-detected engine: {engine_name}")
                        return engine_name
                except:
                    continue
                    
        # Fallback
        return 'socket'
        
    @classmethod
    def list_available(cls) -> List[str]:
        """Список доступных движков."""
        available = []
        for name, engine_class in cls._engines.items():
            try:
                engine = engine_class()
                if engine.is_available():
                    available.append(name)
            except:
                pass
        return available

# Автоматическая регистрация движков
def _auto_register():
    """Автоматическая регистрация всех движков."""
    engines_to_register = [
        ('scapy', 'local.scapy_engine', 'ScapyEngine'),
        ('socket', 'local.socket_engine', 'SocketEngine'),
        ('pydivert', 'system.pydivert_engine', 'PyDivertEngine'),
        ('netfilter', 'system.netfilter_engine', 'NetfilterEngine'),
        ('hybrid', 'hybrid_engine', 'HybridEngine'),
    ]
    
    for name, module_path, class_name in engines_to_register:
        try:
            module = importlib.import_module(f'.{module_path}', 
                                           'recon.core.bypass.engines')
            engine_class = getattr(module, class_name)
            EngineFactory.register(name, engine_class)
        except ImportError:
            pass

_auto_register()
```

## Преимущества рефакторинга:

1. **Единая архитектура** - все движки следуют одному интерфейсу
2. **Модульность** - каждый компонент имеет четкую ответственность
3. **Переиспользование** - общий код в базовых классах
4. **Расширяемость** - легко добавлять новые движки и атаки
5. **Платформонезависимость** - автоматический выбор движка
6. **Тестируемость** - каждый компонент изолирован
7. **Производительность** - оптимизированная обработка пакетов
8. **Поддерживаемость** - четкая структура и документация

Этот рефакторинг превратит разрозненную коллекцию движков в единую, мощную и расширяемую систему обхода DPI.