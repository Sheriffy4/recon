"""
Simple test to verify HTTP analyzer is working correctly
"""

import unittest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

from core.fingerprint.http_analyzer import HTTPAnalyzer, HTTPAnalysisResult


class TestHTTPAnalyzerSimple(unittest.TestCase):
    """Simple tests for HTTP analyzer"""
    
    def setUp(self):
        """Create HTTPAnalyzer instance for testing"""
        self.analyzer = HTTPAnalyzer(timeout=2.0, max_attempts=2)
    
    def test_basic_analysis(self):
        """Test basic HTTP analysis functionality"""
        async def run_test():
            with patch('aiohttp.ClientSession') as mock_session_class:
                mock_session = MagicMock()
                
                # Mock successful response
                mock_response = MagicMock()
                mock_response.status = 200
                mock_response.headers = {'Content-Type': 'text/html', 'Server': 'nginx'}
                mock_response.text = AsyncMock(return_value="<html><body>Test content</body></html>")
                mock_response.__aenter__ = AsyncMock(return_value=mock_response)
                mock_response.__aexit__ = AsyncMock(return_value=None)
                
                mock_session.get = AsyncMock(return_value=mock_response)
                mock_session.__aenter__ = AsyncMock(return_value=mock_session)
                mock_session.__aexit__ = AsyncMock(return_value=None)
                mock_session_class.return_value = mock_session
                
                result = await self.analyzer.analyze_http_behavior("example.com", 443)
                
                self.assertEqual(result['target'], "example.com")
                self.assertIn('timestamp', result)
                self.assertIn('reliability_score', result)
                self.assertIsInstance(result['http_header_filtering'], bool)
                self.assertIsInstance(result['user_agent_filtering'], bool)
                self.assertGreater(result['reliability_score'], 0.5)
        
        asyncio.run(run_test())
    
    def test_blocking_detection(self):
        """Test detection of various blocking methods"""
        async def run_test():
            with patch('aiohttp.ClientSession') as mock_session_class:
                mock_session = MagicMock()
                
                def mock_request_behavior(method, url, *args, **kwargs):
                    headers = kwargs.get('headers', {})
                    data = kwargs.get('data', '')
                    
                    mock_response = MagicMock()
                    mock_response.__aenter__ = AsyncMock(return_value=mock_response)
                    mock_response.__aexit__ = AsyncMock(return_value=None)
                    
                    # Block suspicious user agents
                    user_agent = headers.get('User-Agent', '')
                    if 'curl' in user_agent.lower():
                        raise Exception("Connection reset by peer")
                    
                    # Block certain headers
                    if 'X-Forwarded-For' in headers:
                        raise Exception("Connection reset by peer")
                    
                    # Block certain content
                    if 'vpn' in str(data).lower():
                        mock_response.status = 302
                        mock_response.headers = {
                            'Location': 'https://blocked.example.com',
                            'Content-Type': 'text/html'
                        }
                        mock_response.text = AsyncMock(return_value="<html>Redirecting...</html>")
                        return mock_response
                    
                    # Normal response
                    mock_response.status = 200
                    mock_response.headers = {'Content-Type': 'text/html'}
                    mock_response.text = AsyncMock(return_value="<html><body>Normal content</body></html>")
                    return mock_response
                
                mock_response = MagicMock()
                mock_response.__aenter__ = AsyncMock(return_value=mock_response)
                mock_response.__aexit__ = AsyncMock(return_value=None)
                
                # Block suspicious user agents
                user_agent = headers.get('User-Agent', '')
                if 'curl' in user_agent.lower():
                    raise Exception("Connection reset by peer")
                
                # Block certain headers
                if 'X-Forwarded-For' in headers:
                    raise Exception("Connection reset by peer")
                
                # Block certain content
                if 'vpn' in str(data).lower():
                    mock_response.status = 302
                    mock_response.headers = {
                        'Location': 'https://blocked.example.com',
                        'Content-Type': 'text/html'
                    }
                    mock_response.text = AsyncMock(return_value="<html>Redirecting...</html>")
                    return mock_response
                
                # Normal response
                mock_response.status = 200
                mock_response.headers = {'Content-Type': 'text/html'}
                mock_response.text = AsyncMock(return_value="<html><body>Normal content</body></html>")
                return mock_response
            
            # Set up method mocks
            mock_session.get = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('GET', url, *args, **kwargs))
            mock_session.post = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('POST', url, *args, **kwargs))
            mock_session.put = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('PUT', url, *args, **kwargs))
            mock_session.delete = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('DELETE', url, *args, **kwargs))
            mock_session.head = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('HEAD', url, *args, **kwargs))
            mock_session.options = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('OPTIONS', url, *args, **kwargs))
            mock_session.patch = AsyncMock(side_effect=lambda url, *args, **kwargs: mock_request_behavior('PATCH', url, *args, **kwargs))
            mock_session.request = AsyncMock(side_effect=mock_request_behavior)
            
            mock_session.__aenter__ = AsyncMock(return_value=mock_session)
            mock_session.__aexit__ = AsyncMock(return_value=None)
            mock_session_class.return_value = mock_session
            
            # Run analysis
            result = await self.analyzer.analyze_http_behavior("blocked-site.com", 443)
            
            # Verify blocking detection
            self.assertEqual(result['target'], "blocked-site.com")
            self.assertTrue(result['user_agent_filtering'])
            self.assertTrue(result['http_header_filtering'])
            self.assertTrue(result['redirect_injection'])
            self.assertTrue(result['content_based_blocking'])
            
            # Should have reasonable reliability despite blocking
            self.assertGreater(result['reliability_score'], 0.3)
            
        asyncio.run(run_test())


if __name__ == "__main__":
    unittest.main()