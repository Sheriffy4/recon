"""
Unit tests for multidisorder detailed logging.
def apply_forced_override(original_func, *args, **kwargs):
    """
    –û–±–µ—Ä—Ç–∫–∞ –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π.
    –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –¥–ª—è –∏–¥–µ–Ω—Ç–∏—á–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è —Å —Ä–µ–∂–∏–º–æ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
    """
    # –î–æ–±–∞–≤–ª—è–µ–º forced –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    if len(args) > 1 and isinstance(args[1], dict):
        # –í—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç - —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
        strategy = args[1].copy()
        strategy['no_fallbacks'] = True
        strategy['forced'] = True
        args = (args[0], strategy) + args[2:]
        print(f"üî• FORCED OVERRIDE: Applied to {args[0] if args else 'unknown'}")
    
    return original_func(*args, **kwargs)



Tests that the multidisorder attack logs all important parameters
and execution details for debugging and monitoring.
"""

import pytest
import logging
from unittest.mock import Mock, MagicMock, patch
from core.bypass.engine.base_engine import WindowsBypassEngine, EngineConfig


class TestMultidisorderLogging:
    """Test suite for multidisorder logging functionality."""
    
    @pytest.fixture
    def mock_engine_with_logging(self):
        """Create a mock bypass engine with logging capture."""
        config = EngineConfig(debug=True)
        with patch('core.bypass.engine.base_engine.pydivert'):
            engine = WindowsBypassEngine(config)
            
            # Set up logging capture
            engine.logger.setLevel(logging.DEBUG)
            
            return engine
    
    def test_logs_attack_parameters(self, mock_engine_with_logging, caplog):
        """Test that attack parameters are logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n"
        
        # Mock the packet sender
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Create strategy
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 46,
                "overlap_size": 1,
                "fooling": ["badseq"],
                "ttl": 2,
                "repeats": 2
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that parameters are logged
        log_text = caplog.text
        assert "Multidisorder Attack Parameters" in log_text
        assert "Target: 1.2.3.4:443" in log_text
        assert "Split position: 46" in log_text
        assert "Overlap size: 1" in log_text
        assert "Fooling methods: ['badseq']" in log_text
        assert "TTL: 2" in log_text
        assert "Repeats: 2" in log_text
    
    def test_logs_payload_size(self, mock_engine_with_logging, caplog):
        """Test that payload size is logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet with specific payload size
        payload = b"A" * 100
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = payload
        
        # Mock the packet sender
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Create strategy
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 10,
                "overlap_size": 0,
                "fooling": [],
                "ttl": 1
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that payload size is logged
        assert "Payload size: 100 bytes" in caplog.text
    
    def test_logs_ttl_source(self, mock_engine_with_logging, caplog):
        """Test that TTL source (fixed vs autottl) is logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"Test"
        
        # Mock the packet sender
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Test with fixed TTL
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 2,
                "overlap_size": 0,
                "fooling": [],
                "ttl": 3
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that fixed TTL is logged
        assert "TTL: 3 (fixed)" in caplog.text
    
    def test_logs_autottl_source(self, mock_engine_with_logging, caplog):
        """Test that autottl is logged with offset."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"Test"
        
        # Mock the packet sender
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Mock calculate_autottl
        with patch.object(mock_engine_with_logging, 'calculate_autottl', return_value=10):
            # Test with autottl
            strategy_task = {
                "type": "multidisorder",
                "params": {
                    "split_pos": 2,
                    "overlap_size": 0,
                    "fooling": [],
                    "autottl": 2
                , "no_fallbacks": true, "forced": true}
            }
            
            # Mock WinDivert
            mock_w = Mock()
            
            # Apply bypass
            with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
                mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
            
            # Check that autottl is logged
            assert "TTL: 10 (autottl(offset=2))" in caplog.text
    
    def test_logs_packet_sequence(self, mock_engine_with_logging, caplog):
        """Test that packet sequence is logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"Test payload"
        
        # Mock the packet sender
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Create strategy
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 5,
                "overlap_size": 0,
                "fooling": [],
                "ttl": 1
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that packet sequence is logged
        assert "Packet sequence: 3 segments" in caplog.text
    
    def test_logs_repeat_iterations(self, mock_engine_with_logging, caplog):
        """Test that repeat iterations are logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"Test"
        
        # Mock the packet sender
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Create strategy with repeats
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 2,
                "overlap_size": 0,
                "fooling": [],
                "ttl": 1,
                "repeats": 3
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that repeat iterations are logged
        assert "Repeat iteration 1/3" in caplog.text
        assert "Repeat iteration 2/3" in caplog.text
        assert "Repeat iteration 3/3" in caplog.text
    
    def test_logs_success(self, mock_engine_with_logging, caplog):
        """Test that success is logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"Test"
        
        # Mock the packet sender to return success
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=True)
        
        # Create strategy
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 2,
                "overlap_size": 0,
                "fooling": [],
                "ttl": 1
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that success is logged
        assert "Multidisorder attack completed successfully" in caplog.text
    
    def test_logs_failure(self, mock_engine_with_logging, caplog):
        """Test that failure is logged."""
        caplog.set_level(logging.INFO)
        
        # Create a mock packet
        mock_packet = Mock()
        mock_packet.dst_addr = "1.2.3.4"
        mock_packet.dst_port = 443
        mock_packet.tcp = Mock()
        mock_packet.tcp.syn = False
        mock_packet.tcp.ack = True
        mock_packet.payload = b"Test"
        
        # Mock the packet sender to return failure
        mock_engine_with_logging._packet_sender = Mock()
        mock_engine_with_logging._packet_sender.send_tcp_segments = Mock(return_value=False)
        
        # Create strategy
        strategy_task = {
            "type": "multidisorder",
            "params": {
                "split_pos": 2,
                "overlap_size": 0,
                "fooling": [],
                "ttl": 1
            , "no_fallbacks": true, "forced": true}
        }
        
        # Mock WinDivert
        mock_w = Mock()
        
        # Apply bypass
        with patch.object(mock_engine_with_logging, '_is_tls_clienthello', return_value=False):
            mock_engine_with_logging.apply_bypass(mock_packet, mock_w, strategy_task, forced=True)
        
        # Check that failure is logged
        assert "Multidisorder attack failed" in caplog.text


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
